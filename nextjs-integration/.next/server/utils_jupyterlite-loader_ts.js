"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "utils_jupyterlite-loader_ts";
exports.ids = ["utils_jupyterlite-loader_ts"];
exports.modules = {

/***/ "./utils/jupyterlite-loader.ts":
/*!*************************************!*\
  !*** ./utils/jupyterlite-loader.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupJupyterLiteInstance: () => (/* binding */ cleanupJupyterLiteInstance),\n/* harmony export */   initializeJupyterLiteInContainer: () => (/* binding */ initializeJupyterLiteInContainer)\n/* harmony export */ });\n/**\n * JupyterLite Dynamic Loader for Next.js Integration\n * \n * This module handles the dynamic loading and initialization of JupyterLite\n * within a React component, adapting the bootstrap process for container mounting.\n */ // Global state to track JupyterLite instances\nconst instances = new Map();\n/**\n * Initialize JupyterLite in a specific container element\n */ async function initializeJupyterLiteInContainer(container, configScript, config) {\n    try {\n        console.log(\"\\uD83D\\uDE80 Initializing JupyterLite in container...\");\n        // Clear container safely\n        while(container.firstChild){\n            container.removeChild(container.firstChild);\n        }\n        // Create the placeholder content using DOM methods instead of innerHTML\n        const wrapper = document.createElement(\"div\");\n        wrapper.style.cssText = `\n      display: flex; \n      flex-direction: column; \n      align-items: center; \n      justify-content: center; \n      height: 100%; \n      font-family: system-ui, sans-serif;\n      background: #f5f5f5;\n      border: 2px dashed #ccc;\n      border-radius: 8px;\n      padding: 20px;\n      box-sizing: border-box;\n    `;\n        const title = document.createElement(\"h2\");\n        title.textContent = \"\\uD83C\\uDF89 JupyterLite Next.js Integration\";\n        title.style.cssText = \"color: #333; margin-bottom: 20px; text-align: center;\";\n        const description = document.createElement(\"p\");\n        description.innerHTML = `\n      Success! The integration is working. JupyterLite source code is available in packages/ directory.<br>\n      <strong>Next step:</strong> Build the JupyterLite packages to enable the full Jupyter interface.\n    `;\n        description.style.cssText = \"color: #666; text-align: center; max-width: 500px; line-height: 1.5; margin-bottom: 20px;\";\n        const commandBox = document.createElement(\"div\");\n        commandBox.innerHTML = `\n      <strong>Available Commands:</strong><br>\n      • <code>yarn build:jupyter</code> - Build JupyterLite packages<br>\n      • <code>yarn dev</code> - Start development server<br>\n      • Open browser console to test kernel bridge (when built)\n    `;\n        commandBox.style.cssText = \"margin-top: 20px; padding: 15px; background: #e8f4f8; border-radius: 4px; border-left: 4px solid #0366d6; max-width: 500px;\";\n        const configInfo = document.createElement(\"div\");\n        configInfo.textContent = `Configuration: Theme=${config.theme || \"auto\"}, KernelBridge=${config.enableKernelBridge ? \"enabled\" : \"disabled\"}`;\n        configInfo.style.cssText = \"margin-top: 15px; font-size: 14px; color: #888;\";\n        // Append elements to wrapper\n        wrapper.appendChild(title);\n        wrapper.appendChild(description);\n        wrapper.appendChild(commandBox);\n        wrapper.appendChild(configInfo);\n        // Append wrapper to container\n        container.appendChild(wrapper);\n        console.log(\"✅ JupyterLite container initialized (placeholder mode)\");\n        console.log(\"\\uD83D\\uDCC1 All JupyterLite source code is available in packages/ directory\");\n        console.log('\\uD83D\\uDD28 Run \"yarn build:jupyter\" to build packages and enable full functionality');\n    } catch (error) {\n        console.error(\"Failed to initialize JupyterLite:\", error);\n        throw error;\n    }\n}\n/**\n * Apply theme configuration to the container\n */ async function applyThemeToContainer(container, config) {\n    const loadingIndicator = container.querySelector(\"#jupyterlite-loading-indicator\");\n    if (!loadingIndicator) return;\n    try {\n        // Handle theme application similar to original bootstrap\n        if (config.theme === \"dark\") {\n            container.classList.add(\"jp-mod-dark\");\n            container.classList.remove(\"jp-mod-light\");\n        } else if (config.theme === \"light\") {\n            container.classList.add(\"jp-mod-light\");\n            container.classList.remove(\"jp-mod-dark\");\n        } else if (config.theme === \"auto\") {\n            // Auto-detect theme from stored settings or system preference\n            await applyAutoTheme(container, config);\n        }\n        // Show loading indicator if configured\n        if (config.showLoadingIndicator) {\n            loadingIndicator.classList.remove(\"hidden\");\n        }\n    } catch (error) {\n        console.warn(\"Could not apply theme to container:\", error);\n        // Fallback to light theme\n        container.classList.add(\"jp-mod-light\");\n        container.classList.remove(\"jp-mod-dark\");\n    }\n}\n/**\n * Auto-detect and apply theme based on stored settings or system preference\n */ async function applyAutoTheme(container, config) {\n    try {\n        // Try to load from IndexedDB first\n        const localforageModule = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! localforage */ \"localforage\", 23));\n        const localforage = localforageModule.default;\n        const storageName = config.settingsStorageName || \"JupyterLite Storage\";\n        const settingsDB = localforage.createInstance({\n            name: storageName,\n            storeName: \"settings\"\n        });\n        const key = \"@jupyterlab/apputils-extension:themes\";\n        const settings = await settingsDB.getItem(key);\n        let isDarkTheme = false;\n        if (settings) {\n            // Parse theme from stored settings\n            const themeRegex = /\"theme\"\\s*:\\s*\"([^\"]+)\"/i;\n            const matches = settings.match(themeRegex);\n            if (matches && matches[1]) {\n                const themeName = matches[1].toLowerCase();\n                isDarkTheme = themeName.includes(\"dark\") || themeName.includes(\"night\") || themeName.includes(\"black\");\n            }\n        } else {\n            // Fallback to system preference\n            isDarkTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n        }\n        container.classList.remove(\"jp-mod-dark\", \"jp-mod-light\");\n        container.classList.add(isDarkTheme ? \"jp-mod-dark\" : \"jp-mod-light\");\n    } catch (error) {\n        console.warn(\"Could not auto-detect theme:\", error);\n        // Fallback to system preference\n        const isDarkTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n        container.classList.add(isDarkTheme ? \"jp-mod-dark\" : \"jp-mod-light\");\n    }\n}\n/**\n * Load JupyterLite bootstrap and initialize in container\n */ async function loadJupyterLiteBootstrap(container, config) {\n    // Get configuration from script tag\n    const configData = getConfigurationData();\n    // Load federated extensions\n    const extensionData = configData.federated_extensions || [];\n    const labExtensionUrl = configData.fullLabextensionsUrl || \"/extensions\";\n    // Load all federated extensions\n    const extensions = await Promise.allSettled(extensionData.map(async (data)=>{\n        await loadComponent(`${labExtensionUrl}/${data.name}/${data.load}`, data.name);\n    }));\n    extensions.forEach((p)=>{\n        if (p.status === \"rejected\") {\n            console.error(\"Failed to load extension:\", p.reason);\n        }\n    });\n    // Dynamically import and initialize the main JupyterLite application\n    const jupyterliteModule = await loadJupyterLiteMain();\n    // Initialize JupyterLite with container context\n    await initializeInContainer(jupyterliteModule, container, config);\n}\n/**\n * Load a federated component\n */ async function loadComponent(url, scope) {\n    await loadScript(url);\n    // Initialize webpack module federation\n    await window.__webpack_init_sharing__(\"default\");\n    const container = window._JUPYTERLAB[scope];\n    if (container) {\n        await container.init(window.__webpack_share_scopes__.default);\n    }\n}\n/**\n * Load a script dynamically\n */ function loadScript(url) {\n    return new Promise((resolve, reject)=>{\n        const script = document.createElement(\"script\");\n        script.onload = ()=>resolve();\n        script.onerror = ()=>reject(new Error(`Failed to load script: ${url}`));\n        script.async = true;\n        script.src = url;\n        document.head.appendChild(script);\n    });\n}\n/**\n * Get configuration data from the DOM\n */ function getConfigurationData() {\n    let configData = {};\n    const el = document.getElementById(\"jupyter-config-data\");\n    if (el) {\n        try {\n            configData = JSON.parse(el.textContent || \"{}\");\n        } catch (error) {\n            console.warn(\"Failed to parse jupyter-config-data:\", error);\n        }\n    }\n    return configData;\n}\n/**\n * Dynamically load the main JupyterLite module\n */ async function loadJupyterLiteMain() {\n    // For now, we'll use a simplified approach that loads JupyterLite\n    // by directly executing the bootstrap script in the browser\n    return new Promise((resolve, reject)=>{\n        try {\n            // Create and load the bootstrap script\n            const script = document.createElement(\"script\");\n            script.src = \"/bootstrap.js\";\n            script.onload = ()=>{\n                console.log(\"✓ JupyterLite bootstrap loaded\");\n                resolve({\n                    main: ()=>Promise.resolve()\n                });\n            };\n            script.onerror = ()=>{\n                console.error(\"✗ Failed to load JupyterLite bootstrap\");\n                reject(new Error(\"Failed to load JupyterLite bootstrap.js\"));\n            };\n            document.head.appendChild(script);\n        } catch (error) {\n            reject(new Error(`Failed to load JupyterLite main module: ${error.message}`));\n        }\n    });\n}\n/**\n * Initialize JupyterLite application in the specified container\n */ async function initializeInContainer(jupyterliteModule, container, config) {\n    try {\n        // Hide loading indicator\n        const loadingIndicator = container.querySelector(\"#jupyterlite-loading-indicator\");\n        if (loadingIndicator) {\n            loadingIndicator.classList.add(\"hidden\");\n        }\n        // Initialize the main JupyterLite application\n        // This will depend on the specific API exposed by your built JupyterLite\n        if (jupyterliteModule.main) {\n            await jupyterliteModule.main(container);\n        } else if (jupyterliteModule.default) {\n            await jupyterliteModule.default(container);\n        } else {\n            throw new Error(\"JupyterLite module does not expose expected main function\");\n        }\n        // Initialize kernel bridge if enabled\n        if (config.enableKernelBridge && config.kernelBridgeConfig?.exposeToConsole) {\n            initializeKernelBridgeForContainer(container);\n        }\n        // Remove loading indicator after initialization\n        setTimeout(()=>{\n            if (loadingIndicator) {\n                loadingIndicator.remove();\n            }\n            // Clean up theme classes from container\n            container.classList.remove(\"jp-mod-dark\", \"jp-mod-light\");\n        }, 1000);\n    } catch (error) {\n        console.error(\"Failed to initialize JupyterLite in container:\", error);\n        throw error;\n    }\n}\n/**\n * Initialize kernel bridge for the container instance\n */ function initializeKernelBridgeForContainer(container) {\n    // This would initialize the kernel bridge specifically for this container instance\n    // You might need to adapt the kernel bridge code to work with multiple instances\n    console.log(\"JupyterLite Kernel Bridge initialized for container\");\n    console.log(\"Access via window.jupyter or inspect the container element\");\n    // Store reference to this container's jupyter instance\n    const instanceId = container.id || `container-${Date.now()}`;\n    instances.set(instanceId, {\n        container,\n        jupyter: window.jupyter,\n        bridge: window.jupyterKernelBridge\n    });\n}\n/**\n * Cleanup function for when component unmounts\n */ function cleanupJupyterLiteInstance(container) {\n    // Find and clean up the instance\n    for (const [id, instance] of instances.entries()){\n        if (instance.container === container) {\n            instances.delete(id);\n            break;\n        }\n    }\n    // Clean up any global state if this was the last instance\n    if (instances.size === 0) {\n        // Optionally clean up global JupyterLite state\n        delete window.jupyter;\n        delete window.jupyterKernelBridge;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU0rRixhQUFhbkcsVUFBVW9HLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRUMsS0FBS0MsR0FBRyxHQUFHLENBQUM7SUFDNUR6RyxVQUFVMEcsR0FBRyxDQUFDSixZQUFZO1FBQ3hCbkc7UUFDQXdHLFNBQVN0RCxPQUFPc0QsT0FBTztRQUN2QkMsUUFBUXZELE9BQU93RCxtQkFBbUI7SUFDcEM7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0MsMkJBQTJCM0csU0FBc0I7SUFDL0QsaUNBQWlDO0lBQ2pDLEtBQUssTUFBTSxDQUFDb0csSUFBSVEsU0FBUyxJQUFJL0csVUFBVWdILE9BQU8sR0FBSTtRQUNoRCxJQUFJRCxTQUFTNUcsU0FBUyxLQUFLQSxXQUFXO1lBQ3BDSCxVQUFVaUgsTUFBTSxDQUFDVjtZQUNqQjtRQUNGO0lBQ0Y7SUFFQSwwREFBMEQ7SUFDMUQsSUFBSXZHLFVBQVVrSCxJQUFJLEtBQUssR0FBRztRQUN4QiwrQ0FBK0M7UUFDL0MsT0FBTzdELE9BQU9zRCxPQUFPO1FBQ3JCLE9BQU90RCxPQUFPd0QsbUJBQW1CO0lBQ25DO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXB5dGVybGl0ZS1uZXh0anMtaW50ZWdyYXRpb24vLi91dGlscy9qdXB5dGVybGl0ZS1sb2FkZXIudHM/OWQzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEp1cHl0ZXJMaXRlIER5bmFtaWMgTG9hZGVyIGZvciBOZXh0LmpzIEludGVncmF0aW9uXG4gKiBcbiAqIFRoaXMgbW9kdWxlIGhhbmRsZXMgdGhlIGR5bmFtaWMgbG9hZGluZyBhbmQgaW5pdGlhbGl6YXRpb24gb2YgSnVweXRlckxpdGVcbiAqIHdpdGhpbiBhIFJlYWN0IGNvbXBvbmVudCwgYWRhcHRpbmcgdGhlIGJvb3RzdHJhcCBwcm9jZXNzIGZvciBjb250YWluZXIgbW91bnRpbmcuXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBKdXB5dGVyTGl0ZUNvbmZpZyB9IGZyb20gJy4uL2NvbXBvbmVudHMvSnVweXRlckxpdGVDb21wb25lbnQnO1xuXG4vLyBHbG9iYWwgc3RhdGUgdG8gdHJhY2sgSnVweXRlckxpdGUgaW5zdGFuY2VzXG5jb25zdCBpbnN0YW5jZXMgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuXG4vLyBXZWJwYWNrIHB1YmxpYyBwYXRoIGNvbmZpZ3VyYXRpb25cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX193ZWJwYWNrX3B1YmxpY19wYXRoX186IHN0cmluZztcbiAgICBfSlVQWVRFUkxBQjogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgICBfX3dlYnBhY2tfaW5pdF9zaGFyaW5nX186IChzY29wZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAgIF9fd2VicGFja19zaGFyZV9zY29wZXNfXzogeyBkZWZhdWx0OiBhbnkgfTtcbiAgICBqdXB5dGVyYXBwOiBhbnk7XG4gICAganVweXRlcjogYW55O1xuICAgIGp1cHl0ZXJLZXJuZWxCcmlkZ2U6IGFueTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgSnVweXRlckxpdGUgaW4gYSBzcGVjaWZpYyBjb250YWluZXIgZWxlbWVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZUp1cHl0ZXJMaXRlSW5Db250YWluZXIoXG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gIGNvbmZpZ1NjcmlwdDogSFRNTFNjcmlwdEVsZW1lbnQsXG4gIGNvbmZpZzogSnVweXRlckxpdGVDb25maWdcbik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfwn5qAIEluaXRpYWxpemluZyBKdXB5dGVyTGl0ZSBpbiBjb250YWluZXIuLi4nKTtcbiAgICBcbiAgICAvLyBDbGVhciBjb250YWluZXIgc2FmZWx5XG4gICAgd2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgdGhlIHBsYWNlaG9sZGVyIGNvbnRlbnQgdXNpbmcgRE9NIG1ldGhvZHMgaW5zdGVhZCBvZiBpbm5lckhUTUxcbiAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgZGlzcGxheTogZmxleDsgXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyBcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7IFxuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IFxuICAgICAgaGVpZ2h0OiAxMDAlOyBcbiAgICAgIGZvbnQtZmFtaWx5OiBzeXN0ZW0tdWksIHNhbnMtc2VyaWY7XG4gICAgICBiYWNrZ3JvdW5kOiAjZjVmNWY1O1xuICAgICAgYm9yZGVyOiAycHggZGFzaGVkICNjY2M7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBgO1xuICAgIFxuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICB0aXRsZS50ZXh0Q29udGVudCA9ICfwn46JIEp1cHl0ZXJMaXRlIE5leHQuanMgSW50ZWdyYXRpb24nO1xuICAgIHRpdGxlLnN0eWxlLmNzc1RleHQgPSAnY29sb3I6ICMzMzM7IG1hcmdpbi1ib3R0b206IDIwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsnO1xuICAgIFxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIGRlc2NyaXB0aW9uLmlubmVySFRNTCA9IGBcbiAgICAgIFN1Y2Nlc3MhIFRoZSBpbnRlZ3JhdGlvbiBpcyB3b3JraW5nLiBKdXB5dGVyTGl0ZSBzb3VyY2UgY29kZSBpcyBhdmFpbGFibGUgaW4gcGFja2FnZXMvIGRpcmVjdG9yeS48YnI+XG4gICAgICA8c3Ryb25nPk5leHQgc3RlcDo8L3N0cm9uZz4gQnVpbGQgdGhlIEp1cHl0ZXJMaXRlIHBhY2thZ2VzIHRvIGVuYWJsZSB0aGUgZnVsbCBKdXB5dGVyIGludGVyZmFjZS5cbiAgICBgO1xuICAgIGRlc2NyaXB0aW9uLnN0eWxlLmNzc1RleHQgPSAnY29sb3I6ICM2NjY7IHRleHQtYWxpZ246IGNlbnRlcjsgbWF4LXdpZHRoOiA1MDBweDsgbGluZS1oZWlnaHQ6IDEuNTsgbWFyZ2luLWJvdHRvbTogMjBweDsnO1xuICAgIFxuICAgIGNvbnN0IGNvbW1hbmRCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb21tYW5kQm94LmlubmVySFRNTCA9IGBcbiAgICAgIDxzdHJvbmc+QXZhaWxhYmxlIENvbW1hbmRzOjwvc3Ryb25nPjxicj5cbiAgICAgIOKAoiA8Y29kZT55YXJuIGJ1aWxkOmp1cHl0ZXI8L2NvZGU+IC0gQnVpbGQgSnVweXRlckxpdGUgcGFja2FnZXM8YnI+XG4gICAgICDigKIgPGNvZGU+eWFybiBkZXY8L2NvZGU+IC0gU3RhcnQgZGV2ZWxvcG1lbnQgc2VydmVyPGJyPlxuICAgICAg4oCiIE9wZW4gYnJvd3NlciBjb25zb2xlIHRvIHRlc3Qga2VybmVsIGJyaWRnZSAod2hlbiBidWlsdClcbiAgICBgO1xuICAgIGNvbW1hbmRCb3guc3R5bGUuY3NzVGV4dCA9ICdtYXJnaW4tdG9wOiAyMHB4OyBwYWRkaW5nOiAxNXB4OyBiYWNrZ3JvdW5kOiAjZThmNGY4OyBib3JkZXItcmFkaXVzOiA0cHg7IGJvcmRlci1sZWZ0OiA0cHggc29saWQgIzAzNjZkNjsgbWF4LXdpZHRoOiA1MDBweDsnO1xuICAgIFxuICAgIGNvbnN0IGNvbmZpZ0luZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25maWdJbmZvLnRleHRDb250ZW50ID0gYENvbmZpZ3VyYXRpb246IFRoZW1lPSR7Y29uZmlnLnRoZW1lIHx8ICdhdXRvJ30sIEtlcm5lbEJyaWRnZT0ke2NvbmZpZy5lbmFibGVLZXJuZWxCcmlkZ2UgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfWA7XG4gICAgY29uZmlnSW5mby5zdHlsZS5jc3NUZXh0ID0gJ21hcmdpbi10b3A6IDE1cHg7IGZvbnQtc2l6ZTogMTRweDsgY29sb3I6ICM4ODg7JztcbiAgICBcbiAgICAvLyBBcHBlbmQgZWxlbWVudHMgdG8gd3JhcHBlclxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZGVzY3JpcHRpb24pO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoY29tbWFuZEJveCk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChjb25maWdJbmZvKTtcbiAgICBcbiAgICAvLyBBcHBlbmQgd3JhcHBlciB0byBjb250YWluZXJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ+KchSBKdXB5dGVyTGl0ZSBjb250YWluZXIgaW5pdGlhbGl6ZWQgKHBsYWNlaG9sZGVyIG1vZGUpJyk7XG4gICAgY29uc29sZS5sb2coJ/Cfk4EgQWxsIEp1cHl0ZXJMaXRlIHNvdXJjZSBjb2RlIGlzIGF2YWlsYWJsZSBpbiBwYWNrYWdlcy8gZGlyZWN0b3J5Jyk7XG4gICAgY29uc29sZS5sb2coJ/CflKggUnVuIFwieWFybiBidWlsZDpqdXB5dGVyXCIgdG8gYnVpbGQgcGFja2FnZXMgYW5kIGVuYWJsZSBmdWxsIGZ1bmN0aW9uYWxpdHknKTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIEp1cHl0ZXJMaXRlOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEFwcGx5IHRoZW1lIGNvbmZpZ3VyYXRpb24gdG8gdGhlIGNvbnRhaW5lclxuICovXG5hc3luYyBmdW5jdGlvbiBhcHBseVRoZW1lVG9Db250YWluZXIoXG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIFxuICBjb25maWc6IEp1cHl0ZXJMaXRlQ29uZmlnXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgbG9hZGluZ0luZGljYXRvciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjanVweXRlcmxpdGUtbG9hZGluZy1pbmRpY2F0b3InKTtcbiAgXG4gIGlmICghbG9hZGluZ0luZGljYXRvcikgcmV0dXJuO1xuXG4gIHRyeSB7XG4gICAgLy8gSGFuZGxlIHRoZW1lIGFwcGxpY2F0aW9uIHNpbWlsYXIgdG8gb3JpZ2luYWwgYm9vdHN0cmFwXG4gICAgaWYgKGNvbmZpZy50aGVtZSA9PT0gJ2RhcmsnKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnanAtbW9kLWRhcmsnKTtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdqcC1tb2QtbGlnaHQnKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy50aGVtZSA9PT0gJ2xpZ2h0Jykge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2pwLW1vZC1saWdodCcpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2pwLW1vZC1kYXJrJyk7XG4gICAgfSBlbHNlIGlmIChjb25maWcudGhlbWUgPT09ICdhdXRvJykge1xuICAgICAgLy8gQXV0by1kZXRlY3QgdGhlbWUgZnJvbSBzdG9yZWQgc2V0dGluZ3Mgb3Igc3lzdGVtIHByZWZlcmVuY2VcbiAgICAgIGF3YWl0IGFwcGx5QXV0b1RoZW1lKGNvbnRhaW5lciwgY29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBTaG93IGxvYWRpbmcgaW5kaWNhdG9yIGlmIGNvbmZpZ3VyZWRcbiAgICBpZiAoY29uZmlnLnNob3dMb2FkaW5nSW5kaWNhdG9yKSB7XG4gICAgICBsb2FkaW5nSW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBhcHBseSB0aGVtZSB0byBjb250YWluZXI6JywgZXJyb3IpO1xuICAgIC8vIEZhbGxiYWNrIHRvIGxpZ2h0IHRoZW1lXG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2pwLW1vZC1saWdodCcpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdqcC1tb2QtZGFyaycpO1xuICB9XG59XG5cbi8qKlxuICogQXV0by1kZXRlY3QgYW5kIGFwcGx5IHRoZW1lIGJhc2VkIG9uIHN0b3JlZCBzZXR0aW5ncyBvciBzeXN0ZW0gcHJlZmVyZW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBhcHBseUF1dG9UaGVtZShcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgY29uZmlnOiBKdXB5dGVyTGl0ZUNvbmZpZ1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgLy8gVHJ5IHRvIGxvYWQgZnJvbSBJbmRleGVkREIgZmlyc3RcbiAgICBjb25zdCBsb2NhbGZvcmFnZU1vZHVsZSA9IGF3YWl0IGltcG9ydCgnbG9jYWxmb3JhZ2UnKTtcbiAgICBjb25zdCBsb2NhbGZvcmFnZSA9IGxvY2FsZm9yYWdlTW9kdWxlLmRlZmF1bHQ7XG5cbiAgICBjb25zdCBzdG9yYWdlTmFtZSA9IGNvbmZpZy5zZXR0aW5nc1N0b3JhZ2VOYW1lIHx8ICdKdXB5dGVyTGl0ZSBTdG9yYWdlJztcbiAgICBjb25zdCBzZXR0aW5nc0RCID0gbG9jYWxmb3JhZ2UuY3JlYXRlSW5zdGFuY2Uoe1xuICAgICAgbmFtZTogc3RvcmFnZU5hbWUsXG4gICAgICBzdG9yZU5hbWU6ICdzZXR0aW5ncydcbiAgICB9KTtcblxuICAgIGNvbnN0IGtleSA9ICdAanVweXRlcmxhYi9hcHB1dGlscy1leHRlbnNpb246dGhlbWVzJztcbiAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHNldHRpbmdzREIuZ2V0SXRlbShrZXkpIGFzIHN0cmluZztcblxuICAgIGxldCBpc0RhcmtUaGVtZSA9IGZhbHNlO1xuXG4gICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAvLyBQYXJzZSB0aGVtZSBmcm9tIHN0b3JlZCBzZXR0aW5nc1xuICAgICAgY29uc3QgdGhlbWVSZWdleCA9IC9cInRoZW1lXCJcXHMqOlxccypcIihbXlwiXSspXCIvaTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBzZXR0aW5ncy5tYXRjaCh0aGVtZVJlZ2V4KTtcblxuICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlc1sxXSkge1xuICAgICAgICBjb25zdCB0aGVtZU5hbWUgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlzRGFya1RoZW1lID0gXG4gICAgICAgICAgdGhlbWVOYW1lLmluY2x1ZGVzKCdkYXJrJykgfHxcbiAgICAgICAgICB0aGVtZU5hbWUuaW5jbHVkZXMoJ25pZ2h0JykgfHxcbiAgICAgICAgICB0aGVtZU5hbWUuaW5jbHVkZXMoJ2JsYWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHN5c3RlbSBwcmVmZXJlbmNlXG4gICAgICBpc0RhcmtUaGVtZSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJykubWF0Y2hlcztcbiAgICB9XG5cbiAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnanAtbW9kLWRhcmsnLCAnanAtbW9kLWxpZ2h0Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoaXNEYXJrVGhlbWUgPyAnanAtbW9kLWRhcmsnIDogJ2pwLW1vZC1saWdodCcpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGF1dG8tZGV0ZWN0IHRoZW1lOicsIGVycm9yKTtcbiAgICAvLyBGYWxsYmFjayB0byBzeXN0ZW0gcHJlZmVyZW5jZVxuICAgIGNvbnN0IGlzRGFya1RoZW1lID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGlzRGFya1RoZW1lID8gJ2pwLW1vZC1kYXJrJyA6ICdqcC1tb2QtbGlnaHQnKTtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgSnVweXRlckxpdGUgYm9vdHN0cmFwIGFuZCBpbml0aWFsaXplIGluIGNvbnRhaW5lclxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkSnVweXRlckxpdGVCb290c3RyYXAoXG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gIGNvbmZpZzogSnVweXRlckxpdGVDb25maWdcbik6IFByb21pc2U8dm9pZD4ge1xuICAvLyBHZXQgY29uZmlndXJhdGlvbiBmcm9tIHNjcmlwdCB0YWdcbiAgY29uc3QgY29uZmlnRGF0YSA9IGdldENvbmZpZ3VyYXRpb25EYXRhKCk7XG5cbiAgLy8gTG9hZCBmZWRlcmF0ZWQgZXh0ZW5zaW9uc1xuICBjb25zdCBleHRlbnNpb25EYXRhID0gY29uZmlnRGF0YS5mZWRlcmF0ZWRfZXh0ZW5zaW9ucyB8fCBbXTtcbiAgY29uc3QgbGFiRXh0ZW5zaW9uVXJsID0gY29uZmlnRGF0YS5mdWxsTGFiZXh0ZW5zaW9uc1VybCB8fCAnL2V4dGVuc2lvbnMnO1xuXG4gIC8vIExvYWQgYWxsIGZlZGVyYXRlZCBleHRlbnNpb25zXG4gIGNvbnN0IGV4dGVuc2lvbnMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoXG4gICAgZXh0ZW5zaW9uRGF0YS5tYXAoYXN5bmMgKGRhdGE6IGFueSkgPT4ge1xuICAgICAgYXdhaXQgbG9hZENvbXBvbmVudChgJHtsYWJFeHRlbnNpb25Vcmx9LyR7ZGF0YS5uYW1lfS8ke2RhdGEubG9hZH1gLCBkYXRhLm5hbWUpO1xuICAgIH0pXG4gICk7XG5cbiAgZXh0ZW5zaW9ucy5mb3JFYWNoKHAgPT4ge1xuICAgIGlmIChwLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgZXh0ZW5zaW9uOicsIHAucmVhc29uKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIER5bmFtaWNhbGx5IGltcG9ydCBhbmQgaW5pdGlhbGl6ZSB0aGUgbWFpbiBKdXB5dGVyTGl0ZSBhcHBsaWNhdGlvblxuICBjb25zdCBqdXB5dGVybGl0ZU1vZHVsZSA9IGF3YWl0IGxvYWRKdXB5dGVyTGl0ZU1haW4oKTtcbiAgXG4gIC8vIEluaXRpYWxpemUgSnVweXRlckxpdGUgd2l0aCBjb250YWluZXIgY29udGV4dFxuICBhd2FpdCBpbml0aWFsaXplSW5Db250YWluZXIoanVweXRlcmxpdGVNb2R1bGUsIGNvbnRhaW5lciwgY29uZmlnKTtcbn1cblxuLyoqXG4gKiBMb2FkIGEgZmVkZXJhdGVkIGNvbXBvbmVudFxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkQ29tcG9uZW50KHVybDogc3RyaW5nLCBzY29wZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IGxvYWRTY3JpcHQodXJsKTtcblxuICAvLyBJbml0aWFsaXplIHdlYnBhY2sgbW9kdWxlIGZlZGVyYXRpb25cbiAgYXdhaXQgd2luZG93Ll9fd2VicGFja19pbml0X3NoYXJpbmdfXygnZGVmYXVsdCcpO1xuICBjb25zdCBjb250YWluZXIgPSB3aW5kb3cuX0pVUFlURVJMQUJbc2NvcGVdO1xuICBcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGF3YWl0IGNvbnRhaW5lci5pbml0KHdpbmRvdy5fX3dlYnBhY2tfc2hhcmVfc2NvcGVzX18uZGVmYXVsdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIGEgc2NyaXB0IGR5bmFtaWNhbGx5XG4gKi9cbmZ1bmN0aW9uIGxvYWRTY3JpcHQodXJsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBzY3JpcHQub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgIHNjcmlwdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc2NyaXB0OiAke3VybH1gKSk7XG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGNvbmZpZ3VyYXRpb24gZGF0YSBmcm9tIHRoZSBET01cbiAqL1xuZnVuY3Rpb24gZ2V0Q29uZmlndXJhdGlvbkRhdGEoKTogYW55IHtcbiAgbGV0IGNvbmZpZ0RhdGEgPSB7fTtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnanVweXRlci1jb25maWctZGF0YScpO1xuICBcbiAgaWYgKGVsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZ0RhdGEgPSBKU09OLnBhcnNlKGVsLnRleHRDb250ZW50IHx8ICd7fScpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBqdXB5dGVyLWNvbmZpZy1kYXRhOicsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBjb25maWdEYXRhO1xufVxuXG4vKipcbiAqIER5bmFtaWNhbGx5IGxvYWQgdGhlIG1haW4gSnVweXRlckxpdGUgbW9kdWxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRKdXB5dGVyTGl0ZU1haW4oKTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gRm9yIG5vdywgd2UnbGwgdXNlIGEgc2ltcGxpZmllZCBhcHByb2FjaCB0aGF0IGxvYWRzIEp1cHl0ZXJMaXRlXG4gIC8vIGJ5IGRpcmVjdGx5IGV4ZWN1dGluZyB0aGUgYm9vdHN0cmFwIHNjcmlwdCBpbiB0aGUgYnJvd3NlclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgYW5kIGxvYWQgdGhlIGJvb3RzdHJhcCBzY3JpcHRcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0LnNyYyA9ICcvYm9vdHN0cmFwLmpzJztcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinJMgSnVweXRlckxpdGUgYm9vdHN0cmFwIGxvYWRlZCcpO1xuICAgICAgICByZXNvbHZlKHsgbWFpbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkgfSk7XG4gICAgICB9O1xuICAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KclyBGYWlsZWQgdG8gbG9hZCBKdXB5dGVyTGl0ZSBib290c3RyYXAnKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgSnVweXRlckxpdGUgYm9vdHN0cmFwLmpzJykpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBKdXB5dGVyTGl0ZSBtYWluIG1vZHVsZTogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgSnVweXRlckxpdGUgYXBwbGljYXRpb24gaW4gdGhlIHNwZWNpZmllZCBjb250YWluZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZUluQ29udGFpbmVyKFxuICBqdXB5dGVybGl0ZU1vZHVsZTogYW55LFxuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBjb25maWc6IEp1cHl0ZXJMaXRlQ29uZmlnXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICAvLyBIaWRlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgY29uc3QgbG9hZGluZ0luZGljYXRvciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjanVweXRlcmxpdGUtbG9hZGluZy1pbmRpY2F0b3InKTtcbiAgICBpZiAobG9hZGluZ0luZGljYXRvcikge1xuICAgICAgbG9hZGluZ0luZGljYXRvci5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBtYWluIEp1cHl0ZXJMaXRlIGFwcGxpY2F0aW9uXG4gICAgLy8gVGhpcyB3aWxsIGRlcGVuZCBvbiB0aGUgc3BlY2lmaWMgQVBJIGV4cG9zZWQgYnkgeW91ciBidWlsdCBKdXB5dGVyTGl0ZVxuICAgIGlmIChqdXB5dGVybGl0ZU1vZHVsZS5tYWluKSB7XG4gICAgICBhd2FpdCBqdXB5dGVybGl0ZU1vZHVsZS5tYWluKGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIGlmIChqdXB5dGVybGl0ZU1vZHVsZS5kZWZhdWx0KSB7XG4gICAgICBhd2FpdCBqdXB5dGVybGl0ZU1vZHVsZS5kZWZhdWx0KGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSnVweXRlckxpdGUgbW9kdWxlIGRvZXMgbm90IGV4cG9zZSBleHBlY3RlZCBtYWluIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBrZXJuZWwgYnJpZGdlIGlmIGVuYWJsZWRcbiAgICBpZiAoY29uZmlnLmVuYWJsZUtlcm5lbEJyaWRnZSAmJiBjb25maWcua2VybmVsQnJpZGdlQ29uZmlnPy5leHBvc2VUb0NvbnNvbGUpIHtcbiAgICAgIGluaXRpYWxpemVLZXJuZWxCcmlkZ2VGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgbG9hZGluZyBpbmRpY2F0b3IgYWZ0ZXIgaW5pdGlhbGl6YXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChsb2FkaW5nSW5kaWNhdG9yKSB7XG4gICAgICAgIGxvYWRpbmdJbmRpY2F0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbiB1cCB0aGVtZSBjbGFzc2VzIGZyb20gY29udGFpbmVyXG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnanAtbW9kLWRhcmsnLCAnanAtbW9kLWxpZ2h0Jyk7XG4gICAgfSwgMTAwMCk7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBKdXB5dGVyTGl0ZSBpbiBjb250YWluZXI6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBrZXJuZWwgYnJpZGdlIGZvciB0aGUgY29udGFpbmVyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVLZXJuZWxCcmlkZ2VGb3JDb250YWluZXIoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAvLyBUaGlzIHdvdWxkIGluaXRpYWxpemUgdGhlIGtlcm5lbCBicmlkZ2Ugc3BlY2lmaWNhbGx5IGZvciB0aGlzIGNvbnRhaW5lciBpbnN0YW5jZVxuICAvLyBZb3UgbWlnaHQgbmVlZCB0byBhZGFwdCB0aGUga2VybmVsIGJyaWRnZSBjb2RlIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBpbnN0YW5jZXNcbiAgXG4gIGNvbnNvbGUubG9nKCdKdXB5dGVyTGl0ZSBLZXJuZWwgQnJpZGdlIGluaXRpYWxpemVkIGZvciBjb250YWluZXInKTtcbiAgY29uc29sZS5sb2coJ0FjY2VzcyB2aWEgd2luZG93Lmp1cHl0ZXIgb3IgaW5zcGVjdCB0aGUgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgXG4gIC8vIFN0b3JlIHJlZmVyZW5jZSB0byB0aGlzIGNvbnRhaW5lcidzIGp1cHl0ZXIgaW5zdGFuY2VcbiAgY29uc3QgaW5zdGFuY2VJZCA9IGNvbnRhaW5lci5pZCB8fCBgY29udGFpbmVyLSR7RGF0ZS5ub3coKX1gO1xuICBpbnN0YW5jZXMuc2V0KGluc3RhbmNlSWQsIHtcbiAgICBjb250YWluZXIsXG4gICAganVweXRlcjogd2luZG93Lmp1cHl0ZXIsXG4gICAgYnJpZGdlOiB3aW5kb3cuanVweXRlcktlcm5lbEJyaWRnZVxuICB9KTtcbn1cblxuLyoqXG4gKiBDbGVhbnVwIGZ1bmN0aW9uIGZvciB3aGVuIGNvbXBvbmVudCB1bm1vdW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cEp1cHl0ZXJMaXRlSW5zdGFuY2UoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAvLyBGaW5kIGFuZCBjbGVhbiB1cCB0aGUgaW5zdGFuY2VcbiAgZm9yIChjb25zdCBbaWQsIGluc3RhbmNlXSBvZiBpbnN0YW5jZXMuZW50cmllcygpKSB7XG4gICAgaWYgKGluc3RhbmNlLmNvbnRhaW5lciA9PT0gY29udGFpbmVyKSB7XG4gICAgICBpbnN0YW5jZXMuZGVsZXRlKGlkKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2xlYW4gdXAgYW55IGdsb2JhbCBzdGF0ZSBpZiB0aGlzIHdhcyB0aGUgbGFzdCBpbnN0YW5jZVxuICBpZiAoaW5zdGFuY2VzLnNpemUgPT09IDApIHtcbiAgICAvLyBPcHRpb25hbGx5IGNsZWFuIHVwIGdsb2JhbCBKdXB5dGVyTGl0ZSBzdGF0ZVxuICAgIGRlbGV0ZSB3aW5kb3cuanVweXRlcjtcbiAgICBkZWxldGUgd2luZG93Lmp1cHl0ZXJLZXJuZWxCcmlkZ2U7XG4gIH1cbn0iXSwibmFtZXMiOlsiaW5zdGFuY2VzIiwiTWFwIiwiaW5pdGlhbGl6ZUp1cHl0ZXJMaXRlSW5Db250YWluZXIiLCJjb250YWluZXIiLCJjb25maWdTY3JpcHQiLCJjb25maWciLCJjb25zb2xlIiwibG9nIiwiZmlyc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwid3JhcHBlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsInRpdGxlIiwidGV4dENvbnRlbnQiLCJkZXNjcmlwdGlvbiIsImlubmVySFRNTCIsImNvbW1hbmRCb3giLCJjb25maWdJbmZvIiwidGhlbWUiLCJlbmFibGVLZXJuZWxCcmlkZ2UiLCJhcHBlbmRDaGlsZCIsImVycm9yIiwiYXBwbHlUaGVtZVRvQ29udGFpbmVyIiwibG9hZGluZ0luZGljYXRvciIsInF1ZXJ5U2VsZWN0b3IiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJhcHBseUF1dG9UaGVtZSIsInNob3dMb2FkaW5nSW5kaWNhdG9yIiwid2FybiIsImxvY2FsZm9yYWdlTW9kdWxlIiwibG9jYWxmb3JhZ2UiLCJkZWZhdWx0Iiwic3RvcmFnZU5hbWUiLCJzZXR0aW5nc1N0b3JhZ2VOYW1lIiwic2V0dGluZ3NEQiIsImNyZWF0ZUluc3RhbmNlIiwibmFtZSIsInN0b3JlTmFtZSIsImtleSIsInNldHRpbmdzIiwiZ2V0SXRlbSIsImlzRGFya1RoZW1lIiwidGhlbWVSZWdleCIsIm1hdGNoZXMiLCJtYXRjaCIsInRoZW1lTmFtZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwibG9hZEp1cHl0ZXJMaXRlQm9vdHN0cmFwIiwiY29uZmlnRGF0YSIsImdldENvbmZpZ3VyYXRpb25EYXRhIiwiZXh0ZW5zaW9uRGF0YSIsImZlZGVyYXRlZF9leHRlbnNpb25zIiwibGFiRXh0ZW5zaW9uVXJsIiwiZnVsbExhYmV4dGVuc2lvbnNVcmwiLCJleHRlbnNpb25zIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJtYXAiLCJkYXRhIiwibG9hZENvbXBvbmVudCIsImxvYWQiLCJmb3JFYWNoIiwicCIsInN0YXR1cyIsInJlYXNvbiIsImp1cHl0ZXJsaXRlTW9kdWxlIiwibG9hZEp1cHl0ZXJMaXRlTWFpbiIsImluaXRpYWxpemVJbkNvbnRhaW5lciIsInVybCIsInNjb3BlIiwibG9hZFNjcmlwdCIsIl9fd2VicGFja19pbml0X3NoYXJpbmdfXyIsIl9KVVBZVEVSTEFCIiwiaW5pdCIsIl9fd2VicGFja19zaGFyZV9zY29wZXNfXyIsInJlc29sdmUiLCJyZWplY3QiLCJzY3JpcHQiLCJvbmxvYWQiLCJvbmVycm9yIiwiRXJyb3IiLCJhc3luYyIsInNyYyIsImhlYWQiLCJlbCIsImdldEVsZW1lbnRCeUlkIiwiSlNPTiIsInBhcnNlIiwibWFpbiIsIm1lc3NhZ2UiLCJrZXJuZWxCcmlkZ2VDb25maWciLCJleHBvc2VUb0NvbnNvbGUiLCJpbml0aWFsaXplS2VybmVsQnJpZGdlRm9yQ29udGFpbmVyIiwic2V0VGltZW91dCIsImluc3RhbmNlSWQiLCJpZCIsIkRhdGUiLCJub3ciLCJzZXQiLCJqdXB5dGVyIiwiYnJpZGdlIiwianVweXRlcktlcm5lbEJyaWRnZSIsImNsZWFudXBKdXB5dGVyTGl0ZUluc3RhbmNlIiwiaW5zdGFuY2UiLCJlbnRyaWVzIiwiZGVsZXRlIiwic2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/jupyterlite-loader.ts\n");

/***/ })

};
;