"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["utils_jupyterlite-loader_ts"],{

/***/ "./utils/jupyterlite-loader.ts":
/*!*************************************!*\
  !*** ./utils/jupyterlite-loader.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupJupyterLiteInstance: function() { return /* binding */ cleanupJupyterLiteInstance; },\n/* harmony export */   initializeJupyterLiteInContainer: function() { return /* binding */ initializeJupyterLiteInContainer; }\n/* harmony export */ });\n/**\n * JupyterLite Dynamic Loader for Next.js Integration\n * \n * This module handles the dynamic loading and initialization of JupyterLite\n * within a React component, adapting the bootstrap process for container mounting.\n */ // Global state to track JupyterLite instances\nconst instances = new Map();\n/**\n * Initialize JupyterLite in a specific container element\n */ async function initializeJupyterLiteInContainer(container, configScript, config) {\n    try {\n        console.log(\"\\uD83D\\uDE80 Initializing JupyterLite in container...\");\n        // Clear container safely\n        while(container.firstChild){\n            container.removeChild(container.firstChild);\n        }\n        // Create the placeholder content using DOM methods instead of innerHTML\n        const wrapper = document.createElement(\"div\");\n        wrapper.style.cssText = \"\\n      display: flex; \\n      flex-direction: column; \\n      align-items: center; \\n      justify-content: center; \\n      height: 100%; \\n      font-family: system-ui, sans-serif;\\n      background: #f5f5f5;\\n      border: 2px dashed #ccc;\\n      border-radius: 8px;\\n      padding: 20px;\\n      box-sizing: border-box;\\n    \";\n        const title = document.createElement(\"h2\");\n        title.textContent = \"\\uD83C\\uDF89 JupyterLite Next.js Integration\";\n        title.style.cssText = \"color: #333; margin-bottom: 20px; text-align: center;\";\n        const description = document.createElement(\"p\");\n        description.innerHTML = \"\\n      Success! The integration is working. JupyterLite source code is available in packages/ directory.<br>\\n      <strong>Next step:</strong> Build the JupyterLite packages to enable the full Jupyter interface.\\n    \";\n        description.style.cssText = \"color: #666; text-align: center; max-width: 500px; line-height: 1.5; margin-bottom: 20px;\";\n        const commandBox = document.createElement(\"div\");\n        commandBox.innerHTML = \"\\n      <strong>Available Commands:</strong><br>\\n      • <code>yarn build:jupyter</code> - Build JupyterLite packages<br>\\n      • <code>yarn dev</code> - Start development server<br>\\n      • Open browser console to test kernel bridge (when built)\\n    \";\n        commandBox.style.cssText = \"margin-top: 20px; padding: 15px; background: #e8f4f8; border-radius: 4px; border-left: 4px solid #0366d6; max-width: 500px;\";\n        const configInfo = document.createElement(\"div\");\n        configInfo.textContent = \"Configuration: Theme=\".concat(config.theme || \"auto\", \", KernelBridge=\").concat(config.enableKernelBridge ? \"enabled\" : \"disabled\");\n        configInfo.style.cssText = \"margin-top: 15px; font-size: 14px; color: #888;\";\n        // Append elements to wrapper\n        wrapper.appendChild(title);\n        wrapper.appendChild(description);\n        wrapper.appendChild(commandBox);\n        wrapper.appendChild(configInfo);\n        // Append wrapper to container\n        container.appendChild(wrapper);\n        console.log(\"✅ JupyterLite container initialized (placeholder mode)\");\n        console.log(\"\\uD83D\\uDCC1 All JupyterLite source code is available in packages/ directory\");\n        console.log('\\uD83D\\uDD28 Run \"yarn build:jupyter\" to build packages and enable full functionality');\n    } catch (error) {\n        console.error(\"Failed to initialize JupyterLite:\", error);\n        throw error;\n    }\n}\n/**\n * Apply theme configuration to the container\n */ async function applyThemeToContainer(container, config) {\n    const loadingIndicator = container.querySelector(\"#jupyterlite-loading-indicator\");\n    if (!loadingIndicator) return;\n    try {\n        // Handle theme application similar to original bootstrap\n        if (config.theme === \"dark\") {\n            container.classList.add(\"jp-mod-dark\");\n            container.classList.remove(\"jp-mod-light\");\n        } else if (config.theme === \"light\") {\n            container.classList.add(\"jp-mod-light\");\n            container.classList.remove(\"jp-mod-dark\");\n        } else if (config.theme === \"auto\") {\n            // Auto-detect theme from stored settings or system preference\n            await applyAutoTheme(container, config);\n        }\n        // Show loading indicator if configured\n        if (config.showLoadingIndicator) {\n            loadingIndicator.classList.remove(\"hidden\");\n        }\n    } catch (error) {\n        console.warn(\"Could not apply theme to container:\", error);\n        // Fallback to light theme\n        container.classList.add(\"jp-mod-light\");\n        container.classList.remove(\"jp-mod-dark\");\n    }\n}\n/**\n * Auto-detect and apply theme based on stored settings or system preference\n */ async function applyAutoTheme(container, config) {\n    try {\n        // Try to load from IndexedDB first\n        const localforageModule = await __webpack_require__.e(/*! import() */ \"node_modules_localforage_dist_localforage_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! localforage */ \"./node_modules/localforage/dist/localforage.js\", 23));\n        const localforage = localforageModule.default;\n        const storageName = config.settingsStorageName || \"JupyterLite Storage\";\n        const settingsDB = localforage.createInstance({\n            name: storageName,\n            storeName: \"settings\"\n        });\n        const key = \"@jupyterlab/apputils-extension:themes\";\n        const settings = await settingsDB.getItem(key);\n        let isDarkTheme = false;\n        if (settings) {\n            // Parse theme from stored settings\n            const themeRegex = /\"theme\"\\s*:\\s*\"([^\"]+)\"/i;\n            const matches = settings.match(themeRegex);\n            if (matches && matches[1]) {\n                const themeName = matches[1].toLowerCase();\n                isDarkTheme = themeName.includes(\"dark\") || themeName.includes(\"night\") || themeName.includes(\"black\");\n            }\n        } else {\n            // Fallback to system preference\n            isDarkTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n        }\n        container.classList.remove(\"jp-mod-dark\", \"jp-mod-light\");\n        container.classList.add(isDarkTheme ? \"jp-mod-dark\" : \"jp-mod-light\");\n    } catch (error) {\n        console.warn(\"Could not auto-detect theme:\", error);\n        // Fallback to system preference\n        const isDarkTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n        container.classList.add(isDarkTheme ? \"jp-mod-dark\" : \"jp-mod-light\");\n    }\n}\n/**\n * Load JupyterLite bootstrap and initialize in container\n */ async function loadJupyterLiteBootstrap(container, config) {\n    // Get configuration from script tag\n    const configData = getConfigurationData();\n    // Load federated extensions\n    const extensionData = configData.federated_extensions || [];\n    const labExtensionUrl = configData.fullLabextensionsUrl || \"/extensions\";\n    // Load all federated extensions\n    const extensions = await Promise.allSettled(extensionData.map(async (data)=>{\n        await loadComponent(\"\".concat(labExtensionUrl, \"/\").concat(data.name, \"/\").concat(data.load), data.name);\n    }));\n    extensions.forEach((p)=>{\n        if (p.status === \"rejected\") {\n            console.error(\"Failed to load extension:\", p.reason);\n        }\n    });\n    // Dynamically import and initialize the main JupyterLite application\n    const jupyterliteModule = await loadJupyterLiteMain();\n    // Initialize JupyterLite with container context\n    await initializeInContainer(jupyterliteModule, container, config);\n}\n/**\n * Load a federated component\n */ async function loadComponent(url, scope) {\n    await loadScript(url);\n    // Initialize webpack module federation\n    await window.__webpack_init_sharing__(\"default\");\n    const container = window._JUPYTERLAB[scope];\n    if (container) {\n        await container.init(window.__webpack_share_scopes__.default);\n    }\n}\n/**\n * Load a script dynamically\n */ function loadScript(url) {\n    return new Promise((resolve, reject)=>{\n        const script = document.createElement(\"script\");\n        script.onload = ()=>resolve();\n        script.onerror = ()=>reject(new Error(\"Failed to load script: \".concat(url)));\n        script.async = true;\n        script.src = url;\n        document.head.appendChild(script);\n    });\n}\n/**\n * Get configuration data from the DOM\n */ function getConfigurationData() {\n    let configData = {};\n    const el = document.getElementById(\"jupyter-config-data\");\n    if (el) {\n        try {\n            configData = JSON.parse(el.textContent || \"{}\");\n        } catch (error) {\n            console.warn(\"Failed to parse jupyter-config-data:\", error);\n        }\n    }\n    return configData;\n}\n/**\n * Dynamically load the main JupyterLite module\n */ async function loadJupyterLiteMain() {\n    // For now, we'll use a simplified approach that loads JupyterLite\n    // by directly executing the bootstrap script in the browser\n    return new Promise((resolve, reject)=>{\n        try {\n            // Create and load the bootstrap script\n            const script = document.createElement(\"script\");\n            script.src = \"/bootstrap.js\";\n            script.onload = ()=>{\n                console.log(\"✓ JupyterLite bootstrap loaded\");\n                resolve({\n                    main: ()=>Promise.resolve()\n                });\n            };\n            script.onerror = ()=>{\n                console.error(\"✗ Failed to load JupyterLite bootstrap\");\n                reject(new Error(\"Failed to load JupyterLite bootstrap.js\"));\n            };\n            document.head.appendChild(script);\n        } catch (error) {\n            reject(new Error(\"Failed to load JupyterLite main module: \".concat(error.message)));\n        }\n    });\n}\n/**\n * Initialize JupyterLite application in the specified container\n */ async function initializeInContainer(jupyterliteModule, container, config) {\n    try {\n        var _config_kernelBridgeConfig;\n        // Hide loading indicator\n        const loadingIndicator = container.querySelector(\"#jupyterlite-loading-indicator\");\n        if (loadingIndicator) {\n            loadingIndicator.classList.add(\"hidden\");\n        }\n        // Initialize the main JupyterLite application\n        // This will depend on the specific API exposed by your built JupyterLite\n        if (jupyterliteModule.main) {\n            await jupyterliteModule.main(container);\n        } else if (jupyterliteModule.default) {\n            await jupyterliteModule.default(container);\n        } else {\n            throw new Error(\"JupyterLite module does not expose expected main function\");\n        }\n        // Initialize kernel bridge if enabled\n        if (config.enableKernelBridge && ((_config_kernelBridgeConfig = config.kernelBridgeConfig) === null || _config_kernelBridgeConfig === void 0 ? void 0 : _config_kernelBridgeConfig.exposeToConsole)) {\n            initializeKernelBridgeForContainer(container);\n        }\n        // Remove loading indicator after initialization\n        setTimeout(()=>{\n            if (loadingIndicator) {\n                loadingIndicator.remove();\n            }\n            // Clean up theme classes from container\n            container.classList.remove(\"jp-mod-dark\", \"jp-mod-light\");\n        }, 1000);\n    } catch (error) {\n        console.error(\"Failed to initialize JupyterLite in container:\", error);\n        throw error;\n    }\n}\n/**\n * Initialize kernel bridge for the container instance\n */ function initializeKernelBridgeForContainer(container) {\n    // This would initialize the kernel bridge specifically for this container instance\n    // You might need to adapt the kernel bridge code to work with multiple instances\n    console.log(\"JupyterLite Kernel Bridge initialized for container\");\n    console.log(\"Access via window.jupyter or inspect the container element\");\n    // Store reference to this container's jupyter instance\n    const instanceId = container.id || \"container-\".concat(Date.now());\n    instances.set(instanceId, {\n        container,\n        jupyter: window.jupyter,\n        bridge: window.jupyterKernelBridge\n    });\n}\n/**\n * Cleanup function for when component unmounts\n */ function cleanupJupyterLiteInstance(container) {\n    // Find and clean up the instance\n    for (const [id, instance] of instances.entries()){\n        if (instance.container === container) {\n            instances.delete(id);\n            break;\n        }\n    }\n    // Clean up any global state if this was the last instance\n    if (instances.size === 0) {\n        // Optionally clean up global JupyterLite state\n        delete window.jupyter;\n        delete window.jupyterKernelBridge;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUcsQ0FBQ0osWUFBWTtRQUN4Qm5HO1FBQ0F3RyxTQUFTdEQsT0FBT3NELE9BQU87UUFDdkJDLFFBQVF2RCxPQUFPd0QsbUJBQW1CO0lBQ3BDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLDJCQUEyQjNHLFNBQXNCO0lBQy9ELGlDQUFpQztJQUNqQyxLQUFLLE1BQU0sQ0FBQ29HLElBQUlRLFNBQVMsSUFBSS9HLFVBQVVnSCxPQUFPLEdBQUk7UUFDaEQsSUFBSUQsU0FBUzVHLFNBQVMsS0FBS0EsV0FBVztZQUNwQ0gsVUFBVWlILE1BQU0sQ0FBQ1Y7WUFDakI7UUFDRjtJQUNGO0lBRUEsMERBQTBEO0lBQzFELElBQUl2RyxVQUFVa0gsSUFBSSxLQUFLLEdBQUc7UUFDeEIsK0NBQStDO1FBQy9DLE9BQU83RCxPQUFPc0QsT0FBTztRQUNyQixPQUFPdEQsT0FBT3dELG1CQUFtQjtJQUNuQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2p1cHl0ZXJsaXRlLWxvYWRlci50cz85ZDNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSnVweXRlckxpdGUgRHluYW1pYyBMb2FkZXIgZm9yIE5leHQuanMgSW50ZWdyYXRpb25cbiAqIFxuICogVGhpcyBtb2R1bGUgaGFuZGxlcyB0aGUgZHluYW1pYyBsb2FkaW5nIGFuZCBpbml0aWFsaXphdGlvbiBvZiBKdXB5dGVyTGl0ZVxuICogd2l0aGluIGEgUmVhY3QgY29tcG9uZW50LCBhZGFwdGluZyB0aGUgYm9vdHN0cmFwIHByb2Nlc3MgZm9yIGNvbnRhaW5lciBtb3VudGluZy5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IEp1cHl0ZXJMaXRlQ29uZmlnIH0gZnJvbSAnLi4vY29tcG9uZW50cy9KdXB5dGVyTGl0ZUNvbXBvbmVudCc7XG5cbi8vIEdsb2JhbCBzdGF0ZSB0byB0cmFjayBKdXB5dGVyTGl0ZSBpbnN0YW5jZXNcbmNvbnN0IGluc3RhbmNlcyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG5cbi8vIFdlYnBhY2sgcHVibGljIHBhdGggY29uZmlndXJhdGlvblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBfX3dlYnBhY2tfcHVibGljX3BhdGhfXzogc3RyaW5nO1xuICAgIF9KVVBZVEVSTEFCOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIF9fd2VicGFja19pbml0X3NoYXJpbmdfXzogKHNjb3BlOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gICAgX193ZWJwYWNrX3NoYXJlX3Njb3Blc19fOiB7IGRlZmF1bHQ6IGFueSB9O1xuICAgIGp1cHl0ZXJhcHA6IGFueTtcbiAgICBqdXB5dGVyOiBhbnk7XG4gICAganVweXRlcktlcm5lbEJyaWRnZTogYW55O1xuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBKdXB5dGVyTGl0ZSBpbiBhIHNwZWNpZmljIGNvbnRhaW5lciBlbGVtZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplSnVweXRlckxpdGVJbkNvbnRhaW5lcihcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgY29uZmlnU2NyaXB0OiBIVE1MU2NyaXB0RWxlbWVudCxcbiAgY29uZmlnOiBKdXB5dGVyTGl0ZUNvbmZpZ1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ/CfmoAgSW5pdGlhbGl6aW5nIEp1cHl0ZXJMaXRlIGluIGNvbnRhaW5lci4uLicpO1xuICAgIFxuICAgIC8vIENsZWFyIGNvbnRhaW5lciBzYWZlbHlcbiAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgcGxhY2Vob2xkZXIgY29udGVudCB1c2luZyBET00gbWV0aG9kcyBpbnN0ZWFkIG9mIGlubmVySFRNTFxuICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBkaXNwbGF5OiBmbGV4OyBcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IFxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgXG4gICAgICBoZWlnaHQ6IDEwMCU7IFxuICAgICAgZm9udC1mYW1pbHk6IHN5c3RlbS11aSwgc2Fucy1zZXJpZjtcbiAgICAgIGJhY2tncm91bmQ6ICNmNWY1ZjU7XG4gICAgICBib3JkZXI6IDJweCBkYXNoZWQgI2NjYztcbiAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGA7XG4gICAgXG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuICAgIHRpdGxlLnRleHRDb250ZW50ID0gJ/CfjokgSnVweXRlckxpdGUgTmV4dC5qcyBJbnRlZ3JhdGlvbic7XG4gICAgdGl0bGUuc3R5bGUuY3NzVGV4dCA9ICdjb2xvcjogIzMzMzsgbWFyZ2luLWJvdHRvbTogMjBweDsgdGV4dC1hbGlnbjogY2VudGVyOyc7XG4gICAgXG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgZGVzY3JpcHRpb24uaW5uZXJIVE1MID0gYFxuICAgICAgU3VjY2VzcyEgVGhlIGludGVncmF0aW9uIGlzIHdvcmtpbmcuIEp1cHl0ZXJMaXRlIHNvdXJjZSBjb2RlIGlzIGF2YWlsYWJsZSBpbiBwYWNrYWdlcy8gZGlyZWN0b3J5Ljxicj5cbiAgICAgIDxzdHJvbmc+TmV4dCBzdGVwOjwvc3Ryb25nPiBCdWlsZCB0aGUgSnVweXRlckxpdGUgcGFja2FnZXMgdG8gZW5hYmxlIHRoZSBmdWxsIEp1cHl0ZXIgaW50ZXJmYWNlLlxuICAgIGA7XG4gICAgZGVzY3JpcHRpb24uc3R5bGUuY3NzVGV4dCA9ICdjb2xvcjogIzY2NjsgdGV4dC1hbGlnbjogY2VudGVyOyBtYXgtd2lkdGg6IDUwMHB4OyBsaW5lLWhlaWdodDogMS41OyBtYXJnaW4tYm90dG9tOiAyMHB4Oyc7XG4gICAgXG4gICAgY29uc3QgY29tbWFuZEJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbW1hbmRCb3guaW5uZXJIVE1MID0gYFxuICAgICAgPHN0cm9uZz5BdmFpbGFibGUgQ29tbWFuZHM6PC9zdHJvbmc+PGJyPlxuICAgICAg4oCiIDxjb2RlPnlhcm4gYnVpbGQ6anVweXRlcjwvY29kZT4gLSBCdWlsZCBKdXB5dGVyTGl0ZSBwYWNrYWdlczxicj5cbiAgICAgIOKAoiA8Y29kZT55YXJuIGRldjwvY29kZT4gLSBTdGFydCBkZXZlbG9wbWVudCBzZXJ2ZXI8YnI+XG4gICAgICDigKIgT3BlbiBicm93c2VyIGNvbnNvbGUgdG8gdGVzdCBrZXJuZWwgYnJpZGdlICh3aGVuIGJ1aWx0KVxuICAgIGA7XG4gICAgY29tbWFuZEJveC5zdHlsZS5jc3NUZXh0ID0gJ21hcmdpbi10b3A6IDIwcHg7IHBhZGRpbmc6IDE1cHg7IGJhY2tncm91bmQ6ICNlOGY0Zjg7IGJvcmRlci1yYWRpdXM6IDRweDsgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCAjMDM2NmQ2OyBtYXgtd2lkdGg6IDUwMHB4Oyc7XG4gICAgXG4gICAgY29uc3QgY29uZmlnSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbmZpZ0luZm8udGV4dENvbnRlbnQgPSBgQ29uZmlndXJhdGlvbjogVGhlbWU9JHtjb25maWcudGhlbWUgfHwgJ2F1dG8nfSwgS2VybmVsQnJpZGdlPSR7Y29uZmlnLmVuYWJsZUtlcm5lbEJyaWRnZSA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCd9YDtcbiAgICBjb25maWdJbmZvLnN0eWxlLmNzc1RleHQgPSAnbWFyZ2luLXRvcDogMTVweDsgZm9udC1zaXplOiAxNHB4OyBjb2xvcjogIzg4ODsnO1xuICAgIFxuICAgIC8vIEFwcGVuZCBlbGVtZW50cyB0byB3cmFwcGVyXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChkZXNjcmlwdGlvbik7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChjb21tYW5kQm94KTtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGNvbmZpZ0luZm8pO1xuICAgIFxuICAgIC8vIEFwcGVuZCB3cmFwcGVyIHRvIGNvbnRhaW5lclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn4pyFIEp1cHl0ZXJMaXRlIGNvbnRhaW5lciBpbml0aWFsaXplZCAocGxhY2Vob2xkZXIgbW9kZSknKTtcbiAgICBjb25zb2xlLmxvZygn8J+TgSBBbGwgSnVweXRlckxpdGUgc291cmNlIGNvZGUgaXMgYXZhaWxhYmxlIGluIHBhY2thZ2VzLyBkaXJlY3RvcnknKTtcbiAgICBjb25zb2xlLmxvZygn8J+UqCBSdW4gXCJ5YXJuIGJ1aWxkOmp1cHl0ZXJcIiB0byBidWlsZCBwYWNrYWdlcyBhbmQgZW5hYmxlIGZ1bGwgZnVuY3Rpb25hbGl0eScpO1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgSnVweXRlckxpdGU6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQXBwbHkgdGhlbWUgY29uZmlndXJhdGlvbiB0byB0aGUgY29udGFpbmVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5VGhlbWVUb0NvbnRhaW5lcihcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCwgXG4gIGNvbmZpZzogSnVweXRlckxpdGVDb25maWdcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBsb2FkaW5nSW5kaWNhdG9yID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNqdXB5dGVybGl0ZS1sb2FkaW5nLWluZGljYXRvcicpO1xuICBcbiAgaWYgKCFsb2FkaW5nSW5kaWNhdG9yKSByZXR1cm47XG5cbiAgdHJ5IHtcbiAgICAvLyBIYW5kbGUgdGhlbWUgYXBwbGljYXRpb24gc2ltaWxhciB0byBvcmlnaW5hbCBib290c3RyYXBcbiAgICBpZiAoY29uZmlnLnRoZW1lID09PSAnZGFyaycpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdqcC1tb2QtZGFyaycpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2pwLW1vZC1saWdodCcpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLnRoZW1lID09PSAnbGlnaHQnKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnanAtbW9kLWxpZ2h0Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnanAtbW9kLWRhcmsnKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy50aGVtZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAvLyBBdXRvLWRldGVjdCB0aGVtZSBmcm9tIHN0b3JlZCBzZXR0aW5ncyBvciBzeXN0ZW0gcHJlZmVyZW5jZVxuICAgICAgYXdhaXQgYXBwbHlBdXRvVGhlbWUoY29udGFpbmVyLCBjb25maWcpO1xuICAgIH1cblxuICAgIC8vIFNob3cgbG9hZGluZyBpbmRpY2F0b3IgaWYgY29uZmlndXJlZFxuICAgIGlmIChjb25maWcuc2hvd0xvYWRpbmdJbmRpY2F0b3IpIHtcbiAgICAgIGxvYWRpbmdJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGFwcGx5IHRoZW1lIHRvIGNvbnRhaW5lcjonLCBlcnJvcik7XG4gICAgLy8gRmFsbGJhY2sgdG8gbGlnaHQgdGhlbWVcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnanAtbW9kLWxpZ2h0Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2pwLW1vZC1kYXJrJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdXRvLWRldGVjdCBhbmQgYXBwbHkgdGhlbWUgYmFzZWQgb24gc3RvcmVkIHNldHRpbmdzIG9yIHN5c3RlbSBwcmVmZXJlbmNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5QXV0b1RoZW1lKFxuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBjb25maWc6IEp1cHl0ZXJMaXRlQ29uZmlnXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICAvLyBUcnkgdG8gbG9hZCBmcm9tIEluZGV4ZWREQiBmaXJzdFxuICAgIGNvbnN0IGxvY2FsZm9yYWdlTW9kdWxlID0gYXdhaXQgaW1wb3J0KCdsb2NhbGZvcmFnZScpO1xuICAgIGNvbnN0IGxvY2FsZm9yYWdlID0gbG9jYWxmb3JhZ2VNb2R1bGUuZGVmYXVsdDtcblxuICAgIGNvbnN0IHN0b3JhZ2VOYW1lID0gY29uZmlnLnNldHRpbmdzU3RvcmFnZU5hbWUgfHwgJ0p1cHl0ZXJMaXRlIFN0b3JhZ2UnO1xuICAgIGNvbnN0IHNldHRpbmdzREIgPSBsb2NhbGZvcmFnZS5jcmVhdGVJbnN0YW5jZSh7XG4gICAgICBuYW1lOiBzdG9yYWdlTmFtZSxcbiAgICAgIHN0b3JlTmFtZTogJ3NldHRpbmdzJ1xuICAgIH0pO1xuXG4gICAgY29uc3Qga2V5ID0gJ0BqdXB5dGVybGFiL2FwcHV0aWxzLWV4dGVuc2lvbjp0aGVtZXMnO1xuICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgc2V0dGluZ3NEQi5nZXRJdGVtKGtleSkgYXMgc3RyaW5nO1xuXG4gICAgbGV0IGlzRGFya1RoZW1lID0gZmFsc2U7XG5cbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgIC8vIFBhcnNlIHRoZW1lIGZyb20gc3RvcmVkIHNldHRpbmdzXG4gICAgICBjb25zdCB0aGVtZVJlZ2V4ID0gL1widGhlbWVcIlxccyo6XFxzKlwiKFteXCJdKylcIi9pO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IHNldHRpbmdzLm1hdGNoKHRoZW1lUmVnZXgpO1xuXG4gICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzWzFdKSB7XG4gICAgICAgIGNvbnN0IHRoZW1lTmFtZSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaXNEYXJrVGhlbWUgPSBcbiAgICAgICAgICB0aGVtZU5hbWUuaW5jbHVkZXMoJ2RhcmsnKSB8fFxuICAgICAgICAgIHRoZW1lTmFtZS5pbmNsdWRlcygnbmlnaHQnKSB8fFxuICAgICAgICAgIHRoZW1lTmFtZS5pbmNsdWRlcygnYmxhY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gc3lzdGVtIHByZWZlcmVuY2VcbiAgICAgIGlzRGFya1RoZW1lID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzO1xuICAgIH1cblxuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdqcC1tb2QtZGFyaycsICdqcC1tb2QtbGlnaHQnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChpc0RhcmtUaGVtZSA/ICdqcC1tb2QtZGFyaycgOiAnanAtbW9kLWxpZ2h0Jyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgYXV0by1kZXRlY3QgdGhlbWU6JywgZXJyb3IpO1xuICAgIC8vIEZhbGxiYWNrIHRvIHN5c3RlbSBwcmVmZXJlbmNlXG4gICAgY29uc3QgaXNEYXJrVGhlbWUgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpLm1hdGNoZXM7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoaXNEYXJrVGhlbWUgPyAnanAtbW9kLWRhcmsnIDogJ2pwLW1vZC1saWdodCcpO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBKdXB5dGVyTGl0ZSBib290c3RyYXAgYW5kIGluaXRpYWxpemUgaW4gY29udGFpbmVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRKdXB5dGVyTGl0ZUJvb3RzdHJhcChcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgY29uZmlnOiBKdXB5dGVyTGl0ZUNvbmZpZ1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIEdldCBjb25maWd1cmF0aW9uIGZyb20gc2NyaXB0IHRhZ1xuICBjb25zdCBjb25maWdEYXRhID0gZ2V0Q29uZmlndXJhdGlvbkRhdGEoKTtcblxuICAvLyBMb2FkIGZlZGVyYXRlZCBleHRlbnNpb25zXG4gIGNvbnN0IGV4dGVuc2lvbkRhdGEgPSBjb25maWdEYXRhLmZlZGVyYXRlZF9leHRlbnNpb25zIHx8IFtdO1xuICBjb25zdCBsYWJFeHRlbnNpb25VcmwgPSBjb25maWdEYXRhLmZ1bGxMYWJleHRlbnNpb25zVXJsIHx8ICcvZXh0ZW5zaW9ucyc7XG5cbiAgLy8gTG9hZCBhbGwgZmVkZXJhdGVkIGV4dGVuc2lvbnNcbiAgY29uc3QgZXh0ZW5zaW9ucyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChcbiAgICBleHRlbnNpb25EYXRhLm1hcChhc3luYyAoZGF0YTogYW55KSA9PiB7XG4gICAgICBhd2FpdCBsb2FkQ29tcG9uZW50KGAke2xhYkV4dGVuc2lvblVybH0vJHtkYXRhLm5hbWV9LyR7ZGF0YS5sb2FkfWAsIGRhdGEubmFtZSk7XG4gICAgfSlcbiAgKTtcblxuICBleHRlbnNpb25zLmZvckVhY2gocCA9PiB7XG4gICAgaWYgKHAuc3RhdHVzID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBleHRlbnNpb246JywgcC5yZWFzb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRHluYW1pY2FsbHkgaW1wb3J0IGFuZCBpbml0aWFsaXplIHRoZSBtYWluIEp1cHl0ZXJMaXRlIGFwcGxpY2F0aW9uXG4gIGNvbnN0IGp1cHl0ZXJsaXRlTW9kdWxlID0gYXdhaXQgbG9hZEp1cHl0ZXJMaXRlTWFpbigpO1xuICBcbiAgLy8gSW5pdGlhbGl6ZSBKdXB5dGVyTGl0ZSB3aXRoIGNvbnRhaW5lciBjb250ZXh0XG4gIGF3YWl0IGluaXRpYWxpemVJbkNvbnRhaW5lcihqdXB5dGVybGl0ZU1vZHVsZSwgY29udGFpbmVyLCBjb25maWcpO1xufVxuXG4vKipcbiAqIExvYWQgYSBmZWRlcmF0ZWQgY29tcG9uZW50XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRDb21wb25lbnQodXJsOiBzdHJpbmcsIHNjb3BlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgbG9hZFNjcmlwdCh1cmwpO1xuXG4gIC8vIEluaXRpYWxpemUgd2VicGFjayBtb2R1bGUgZmVkZXJhdGlvblxuICBhd2FpdCB3aW5kb3cuX193ZWJwYWNrX2luaXRfc2hhcmluZ19fKCdkZWZhdWx0Jyk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHdpbmRvdy5fSlVQWVRFUkxBQltzY29wZV07XG4gIFxuICBpZiAoY29udGFpbmVyKSB7XG4gICAgYXdhaXQgY29udGFpbmVyLmluaXQod2luZG93Ll9fd2VicGFja19zaGFyZV9zY29wZXNfXy5kZWZhdWx0KTtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgYSBzY3JpcHQgZHluYW1pY2FsbHlcbiAqL1xuZnVuY3Rpb24gbG9hZFNjcmlwdCh1cmw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzY3JpcHQ6ICR7dXJsfWApKTtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgY29uZmlndXJhdGlvbiBkYXRhIGZyb20gdGhlIERPTVxuICovXG5mdW5jdGlvbiBnZXRDb25maWd1cmF0aW9uRGF0YSgpOiBhbnkge1xuICBsZXQgY29uZmlnRGF0YSA9IHt9O1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqdXB5dGVyLWNvbmZpZy1kYXRhJyk7XG4gIFxuICBpZiAoZWwpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnRGF0YSA9IEpTT04ucGFyc2UoZWwudGV4dENvbnRlbnQgfHwgJ3t9Jyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGp1cHl0ZXItY29uZmlnLWRhdGE6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGNvbmZpZ0RhdGE7XG59XG5cbi8qKlxuICogRHluYW1pY2FsbHkgbG9hZCB0aGUgbWFpbiBKdXB5dGVyTGl0ZSBtb2R1bGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZEp1cHl0ZXJMaXRlTWFpbigpOiBQcm9taXNlPGFueT4ge1xuICAvLyBGb3Igbm93LCB3ZSdsbCB1c2UgYSBzaW1wbGlmaWVkIGFwcHJvYWNoIHRoYXQgbG9hZHMgSnVweXRlckxpdGVcbiAgLy8gYnkgZGlyZWN0bHkgZXhlY3V0aW5nIHRoZSBib290c3RyYXAgc2NyaXB0IGluIHRoZSBicm93c2VyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSBhbmQgbG9hZCB0aGUgYm9vdHN0cmFwIHNjcmlwdFxuICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQuc3JjID0gJy9ib290c3RyYXAuanMnO1xuICAgICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KckyBKdXB5dGVyTGl0ZSBib290c3RyYXAgbG9hZGVkJyk7XG4gICAgICAgIHJlc29sdmUoeyBtYWluOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSB9KTtcbiAgICAgIH07XG4gICAgICBzY3JpcHQub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4pyXIEZhaWxlZCB0byBsb2FkIEp1cHl0ZXJMaXRlIGJvb3RzdHJhcCcpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBKdXB5dGVyTGl0ZSBib290c3RyYXAuanMnKSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIEp1cHl0ZXJMaXRlIG1haW4gbW9kdWxlOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBKdXB5dGVyTGl0ZSBhcHBsaWNhdGlvbiBpbiB0aGUgc3BlY2lmaWVkIGNvbnRhaW5lclxuICovXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplSW5Db250YWluZXIoXG4gIGp1cHl0ZXJsaXRlTW9kdWxlOiBhbnksXG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gIGNvbmZpZzogSnVweXRlckxpdGVDb25maWdcbik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIC8vIEhpZGUgbG9hZGluZyBpbmRpY2F0b3JcbiAgICBjb25zdCBsb2FkaW5nSW5kaWNhdG9yID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNqdXB5dGVybGl0ZS1sb2FkaW5nLWluZGljYXRvcicpO1xuICAgIGlmIChsb2FkaW5nSW5kaWNhdG9yKSB7XG4gICAgICBsb2FkaW5nSW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIG1haW4gSnVweXRlckxpdGUgYXBwbGljYXRpb25cbiAgICAvLyBUaGlzIHdpbGwgZGVwZW5kIG9uIHRoZSBzcGVjaWZpYyBBUEkgZXhwb3NlZCBieSB5b3VyIGJ1aWx0IEp1cHl0ZXJMaXRlXG4gICAgaWYgKGp1cHl0ZXJsaXRlTW9kdWxlLm1haW4pIHtcbiAgICAgIGF3YWl0IGp1cHl0ZXJsaXRlTW9kdWxlLm1haW4oY29udGFpbmVyKTtcbiAgICB9IGVsc2UgaWYgKGp1cHl0ZXJsaXRlTW9kdWxlLmRlZmF1bHQpIHtcbiAgICAgIGF3YWl0IGp1cHl0ZXJsaXRlTW9kdWxlLmRlZmF1bHQoY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdKdXB5dGVyTGl0ZSBtb2R1bGUgZG9lcyBub3QgZXhwb3NlIGV4cGVjdGVkIG1haW4gZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGtlcm5lbCBicmlkZ2UgaWYgZW5hYmxlZFxuICAgIGlmIChjb25maWcuZW5hYmxlS2VybmVsQnJpZGdlICYmIGNvbmZpZy5rZXJuZWxCcmlkZ2VDb25maWc/LmV4cG9zZVRvQ29uc29sZSkge1xuICAgICAgaW5pdGlhbGl6ZUtlcm5lbEJyaWRnZUZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBsb2FkaW5nIGluZGljYXRvciBhZnRlciBpbml0aWFsaXphdGlvblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGxvYWRpbmdJbmRpY2F0b3IpIHtcbiAgICAgICAgbG9hZGluZ0luZGljYXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFuIHVwIHRoZW1lIGNsYXNzZXMgZnJvbSBjb250YWluZXJcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdqcC1tb2QtZGFyaycsICdqcC1tb2QtbGlnaHQnKTtcbiAgICB9LCAxMDAwKTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIEp1cHl0ZXJMaXRlIGluIGNvbnRhaW5lcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGtlcm5lbCBicmlkZ2UgZm9yIHRoZSBjb250YWluZXIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUtlcm5lbEJyaWRnZUZvckNvbnRhaW5lcihjb250YWluZXI6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gIC8vIFRoaXMgd291bGQgaW5pdGlhbGl6ZSB0aGUga2VybmVsIGJyaWRnZSBzcGVjaWZpY2FsbHkgZm9yIHRoaXMgY29udGFpbmVyIGluc3RhbmNlXG4gIC8vIFlvdSBtaWdodCBuZWVkIHRvIGFkYXB0IHRoZSBrZXJuZWwgYnJpZGdlIGNvZGUgdG8gd29yayB3aXRoIG11bHRpcGxlIGluc3RhbmNlc1xuICBcbiAgY29uc29sZS5sb2coJ0p1cHl0ZXJMaXRlIEtlcm5lbCBCcmlkZ2UgaW5pdGlhbGl6ZWQgZm9yIGNvbnRhaW5lcicpO1xuICBjb25zb2xlLmxvZygnQWNjZXNzIHZpYSB3aW5kb3cuanVweXRlciBvciBpbnNwZWN0IHRoZSBjb250YWluZXIgZWxlbWVudCcpO1xuICBcbiAgLy8gU3RvcmUgcmVmZXJlbmNlIHRvIHRoaXMgY29udGFpbmVyJ3MganVweXRlciBpbnN0YW5jZVxuICBjb25zdCBpbnN0YW5jZUlkID0gY29udGFpbmVyLmlkIHx8IGBjb250YWluZXItJHtEYXRlLm5vdygpfWA7XG4gIGluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZCwge1xuICAgIGNvbnRhaW5lcixcbiAgICBqdXB5dGVyOiB3aW5kb3cuanVweXRlcixcbiAgICBicmlkZ2U6IHdpbmRvdy5qdXB5dGVyS2VybmVsQnJpZGdlXG4gIH0pO1xufVxuXG4vKipcbiAqIENsZWFudXAgZnVuY3Rpb24gZm9yIHdoZW4gY29tcG9uZW50IHVubW91bnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwSnVweXRlckxpdGVJbnN0YW5jZShjb250YWluZXI6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gIC8vIEZpbmQgYW5kIGNsZWFuIHVwIHRoZSBpbnN0YW5jZVxuICBmb3IgKGNvbnN0IFtpZCwgaW5zdGFuY2VdIG9mIGluc3RhbmNlcy5lbnRyaWVzKCkpIHtcbiAgICBpZiAoaW5zdGFuY2UuY29udGFpbmVyID09PSBjb250YWluZXIpIHtcbiAgICAgIGluc3RhbmNlcy5kZWxldGUoaWQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDbGVhbiB1cCBhbnkgZ2xvYmFsIHN0YXRlIGlmIHRoaXMgd2FzIHRoZSBsYXN0IGluc3RhbmNlXG4gIGlmIChpbnN0YW5jZXMuc2l6ZSA9PT0gMCkge1xuICAgIC8vIE9wdGlvbmFsbHkgY2xlYW4gdXAgZ2xvYmFsIEp1cHl0ZXJMaXRlIHN0YXRlXG4gICAgZGVsZXRlIHdpbmRvdy5qdXB5dGVyO1xuICAgIGRlbGV0ZSB3aW5kb3cuanVweXRlcktlcm5lbEJyaWRnZTtcbiAgfVxufSJdLCJuYW1lcyI6WyJpbnN0YW5jZXMiLCJNYXAiLCJpbml0aWFsaXplSnVweXRlckxpdGVJbkNvbnRhaW5lciIsImNvbnRhaW5lciIsImNvbmZpZ1NjcmlwdCIsImNvbmZpZyIsImNvbnNvbGUiLCJsb2ciLCJmaXJzdENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJ3cmFwcGVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJjc3NUZXh0IiwidGl0bGUiLCJ0ZXh0Q29udGVudCIsImRlc2NyaXB0aW9uIiwiaW5uZXJIVE1MIiwiY29tbWFuZEJveCIsImNvbmZpZ0luZm8iLCJ0aGVtZSIsImVuYWJsZUtlcm5lbEJyaWRnZSIsImFwcGVuZENoaWxkIiwiZXJyb3IiLCJhcHBseVRoZW1lVG9Db250YWluZXIiLCJsb2FkaW5nSW5kaWNhdG9yIiwicXVlcnlTZWxlY3RvciIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSIsImFwcGx5QXV0b1RoZW1lIiwic2hvd0xvYWRpbmdJbmRpY2F0b3IiLCJ3YXJuIiwibG9jYWxmb3JhZ2VNb2R1bGUiLCJsb2NhbGZvcmFnZSIsImRlZmF1bHQiLCJzdG9yYWdlTmFtZSIsInNldHRpbmdzU3RvcmFnZU5hbWUiLCJzZXR0aW5nc0RCIiwiY3JlYXRlSW5zdGFuY2UiLCJuYW1lIiwic3RvcmVOYW1lIiwia2V5Iiwic2V0dGluZ3MiLCJnZXRJdGVtIiwiaXNEYXJrVGhlbWUiLCJ0aGVtZVJlZ2V4IiwibWF0Y2hlcyIsIm1hdGNoIiwidGhlbWVOYW1lIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJsb2FkSnVweXRlckxpdGVCb290c3RyYXAiLCJjb25maWdEYXRhIiwiZ2V0Q29uZmlndXJhdGlvbkRhdGEiLCJleHRlbnNpb25EYXRhIiwiZmVkZXJhdGVkX2V4dGVuc2lvbnMiLCJsYWJFeHRlbnNpb25VcmwiLCJmdWxsTGFiZXh0ZW5zaW9uc1VybCIsImV4dGVuc2lvbnMiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsIm1hcCIsImRhdGEiLCJsb2FkQ29tcG9uZW50IiwibG9hZCIsImZvckVhY2giLCJwIiwic3RhdHVzIiwicmVhc29uIiwianVweXRlcmxpdGVNb2R1bGUiLCJsb2FkSnVweXRlckxpdGVNYWluIiwiaW5pdGlhbGl6ZUluQ29udGFpbmVyIiwidXJsIiwic2NvcGUiLCJsb2FkU2NyaXB0IiwiX193ZWJwYWNrX2luaXRfc2hhcmluZ19fIiwiX0pVUFlURVJMQUIiLCJpbml0IiwiX193ZWJwYWNrX3NoYXJlX3Njb3Blc19fIiwicmVzb2x2ZSIsInJlamVjdCIsInNjcmlwdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJFcnJvciIsImFzeW5jIiwic3JjIiwiaGVhZCIsImVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJKU09OIiwicGFyc2UiLCJtYWluIiwibWVzc2FnZSIsImtlcm5lbEJyaWRnZUNvbmZpZyIsImV4cG9zZVRvQ29uc29sZSIsImluaXRpYWxpemVLZXJuZWxCcmlkZ2VGb3JDb250YWluZXIiLCJzZXRUaW1lb3V0IiwiaW5zdGFuY2VJZCIsImlkIiwiRGF0ZSIsIm5vdyIsInNldCIsImp1cHl0ZXIiLCJicmlkZ2UiLCJqdXB5dGVyS2VybmVsQnJpZGdlIiwiY2xlYW51cEp1cHl0ZXJMaXRlSW5zdGFuY2UiLCJpbnN0YW5jZSIsImVudHJpZXMiLCJkZWxldGUiLCJzaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/jupyterlite-loader.ts\n"));

/***/ })

}]);