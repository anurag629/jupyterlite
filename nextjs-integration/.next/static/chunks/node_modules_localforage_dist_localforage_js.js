/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_localforage_dist_localforage_js"],{

/***/ "./node_modules/localforage/dist/localforage.js":
/*!******************************************************!*\
  !*** ./node_modules/localforage/dist/localforage.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { \"@babel/helpers - typeof\"; return _typeof2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof2(obj); }\n/*!\n    localForage -- Offline Storage, Improved\n    Version 1.10.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function (f) {\n  if (( false ? 0 : _typeof2(exports)) === \"object\" && \"object\" !== \"undefined\") {\n    module.exports = f();\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var g; }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = undefined;\n          if (!u && a) return require(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n      return n[o].exports;\n    }\n    var i = undefined;\n    for (var o = 0; o < r.length; o++) s(r[o]);\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      (function (global) {\n        'use strict';\n\n        var Mutation = global.MutationObserver || global.WebKitMutationObserver;\n        var scheduleDrain;\n        {\n          if (Mutation) {\n            var called = 0;\n            var observer = new Mutation(nextTick);\n            var element = global.document.createTextNode('');\n            observer.observe(element, {\n              characterData: true\n            });\n            scheduleDrain = function scheduleDrain() {\n              element.data = called = ++called % 2;\n            };\n          } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n            var channel = new global.MessageChannel();\n            channel.port1.onmessage = nextTick;\n            scheduleDrain = function scheduleDrain() {\n              channel.port2.postMessage(0);\n            };\n          } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n            scheduleDrain = function scheduleDrain() {\n              // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n              // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n              var scriptEl = global.document.createElement('script');\n              scriptEl.onreadystatechange = function () {\n                nextTick();\n                scriptEl.onreadystatechange = null;\n                scriptEl.parentNode.removeChild(scriptEl);\n                scriptEl = null;\n              };\n              global.document.documentElement.appendChild(scriptEl);\n            };\n          } else {\n            scheduleDrain = function scheduleDrain() {\n              setTimeout(nextTick, 0);\n            };\n          }\n        }\n        var draining;\n        var queue = [];\n        //named nextTick for less confusing stack traces\n        function nextTick() {\n          draining = true;\n          var i, oldQueue;\n          var len = queue.length;\n          while (len) {\n            oldQueue = queue;\n            queue = [];\n            i = -1;\n            while (++i < len) {\n              oldQueue[i]();\n            }\n            len = queue.length;\n          }\n          draining = false;\n        }\n        module.exports = immediate;\n        function immediate(task) {\n          if (queue.push(task) === 1 && !draining) {\n            scheduleDrain();\n          }\n        }\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    2: [function (_dereq_, module, exports) {\n      'use strict';\n\n      var immediate = _dereq_(1);\n\n      /* istanbul ignore next */\n      function INTERNAL() {}\n      var handlers = {};\n      var REJECTED = ['REJECTED'];\n      var FULFILLED = ['FULFILLED'];\n      var PENDING = ['PENDING'];\n      module.exports = Promise;\n      function Promise(resolver) {\n        if (typeof resolver !== 'function') {\n          throw new TypeError('resolver must be a function');\n        }\n        this.state = PENDING;\n        this.queue = [];\n        this.outcome = void 0;\n        if (resolver !== INTERNAL) {\n          safelyResolveThenable(this, resolver);\n        }\n      }\n      Promise.prototype[\"catch\"] = function (onRejected) {\n        return this.then(null, onRejected);\n      };\n      Promise.prototype.then = function (onFulfilled, onRejected) {\n        if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {\n          return this;\n        }\n        var promise = new this.constructor(INTERNAL);\n        if (this.state !== PENDING) {\n          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n          unwrap(promise, resolver, this.outcome);\n        } else {\n          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n        }\n        return promise;\n      };\n      function QueueItem(promise, onFulfilled, onRejected) {\n        this.promise = promise;\n        if (typeof onFulfilled === 'function') {\n          this.onFulfilled = onFulfilled;\n          this.callFulfilled = this.otherCallFulfilled;\n        }\n        if (typeof onRejected === 'function') {\n          this.onRejected = onRejected;\n          this.callRejected = this.otherCallRejected;\n        }\n      }\n      QueueItem.prototype.callFulfilled = function (value) {\n        handlers.resolve(this.promise, value);\n      };\n      QueueItem.prototype.otherCallFulfilled = function (value) {\n        unwrap(this.promise, this.onFulfilled, value);\n      };\n      QueueItem.prototype.callRejected = function (value) {\n        handlers.reject(this.promise, value);\n      };\n      QueueItem.prototype.otherCallRejected = function (value) {\n        unwrap(this.promise, this.onRejected, value);\n      };\n      function unwrap(promise, func, value) {\n        immediate(function () {\n          var returnValue;\n          try {\n            returnValue = func(value);\n          } catch (e) {\n            return handlers.reject(promise, e);\n          }\n          if (returnValue === promise) {\n            handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n          } else {\n            handlers.resolve(promise, returnValue);\n          }\n        });\n      }\n      handlers.resolve = function (self, value) {\n        var result = tryCatch(getThen, value);\n        if (result.status === 'error') {\n          return handlers.reject(self, result.value);\n        }\n        var thenable = result.value;\n        if (thenable) {\n          safelyResolveThenable(self, thenable);\n        } else {\n          self.state = FULFILLED;\n          self.outcome = value;\n          var i = -1;\n          var len = self.queue.length;\n          while (++i < len) {\n            self.queue[i].callFulfilled(value);\n          }\n        }\n        return self;\n      };\n      handlers.reject = function (self, error) {\n        self.state = REJECTED;\n        self.outcome = error;\n        var i = -1;\n        var len = self.queue.length;\n        while (++i < len) {\n          self.queue[i].callRejected(error);\n        }\n        return self;\n      };\n      function getThen(obj) {\n        // Make sure we only access the accessor once as required by the spec\n        var then = obj && obj.then;\n        if (obj && (_typeof2(obj) === 'object' || typeof obj === 'function') && typeof then === 'function') {\n          return function appyThen() {\n            then.apply(obj, arguments);\n          };\n        }\n      }\n      function safelyResolveThenable(self, thenable) {\n        // Either fulfill, reject or reject with error\n        var called = false;\n        function onError(value) {\n          if (called) {\n            return;\n          }\n          called = true;\n          handlers.reject(self, value);\n        }\n        function onSuccess(value) {\n          if (called) {\n            return;\n          }\n          called = true;\n          handlers.resolve(self, value);\n        }\n        function tryToUnwrap() {\n          thenable(onSuccess, onError);\n        }\n        var result = tryCatch(tryToUnwrap);\n        if (result.status === 'error') {\n          onError(result.value);\n        }\n      }\n      function tryCatch(func, value) {\n        var out = {};\n        try {\n          out.value = func(value);\n          out.status = 'success';\n        } catch (e) {\n          out.status = 'error';\n          out.value = e;\n        }\n        return out;\n      }\n      Promise.resolve = resolve;\n      function resolve(value) {\n        if (value instanceof this) {\n          return value;\n        }\n        return handlers.resolve(new this(INTERNAL), value);\n      }\n      Promise.reject = reject;\n      function reject(reason) {\n        var promise = new this(INTERNAL);\n        return handlers.reject(promise, reason);\n      }\n      Promise.all = all;\n      function all(iterable) {\n        var self = this;\n        if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n          return this.reject(new TypeError('must be an array'));\n        }\n        var len = iterable.length;\n        var called = false;\n        if (!len) {\n          return this.resolve([]);\n        }\n        var values = new Array(len);\n        var resolved = 0;\n        var i = -1;\n        var promise = new this(INTERNAL);\n        while (++i < len) {\n          allResolver(iterable[i], i);\n        }\n        return promise;\n        function allResolver(value, i) {\n          self.resolve(value).then(resolveFromAll, function (error) {\n            if (!called) {\n              called = true;\n              handlers.reject(promise, error);\n            }\n          });\n          function resolveFromAll(outValue) {\n            values[i] = outValue;\n            if (++resolved === len && !called) {\n              called = true;\n              handlers.resolve(promise, values);\n            }\n          }\n        }\n      }\n      Promise.race = race;\n      function race(iterable) {\n        var self = this;\n        if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n          return this.reject(new TypeError('must be an array'));\n        }\n        var len = iterable.length;\n        var called = false;\n        if (!len) {\n          return this.resolve([]);\n        }\n        var i = -1;\n        var promise = new this(INTERNAL);\n        while (++i < len) {\n          resolver(iterable[i]);\n        }\n        return promise;\n        function resolver(value) {\n          self.resolve(value).then(function (response) {\n            if (!called) {\n              called = true;\n              handlers.resolve(promise, response);\n            }\n          }, function (error) {\n            if (!called) {\n              called = true;\n              handlers.reject(promise, error);\n            }\n          });\n        }\n      }\n    }, {\n      \"1\": 1\n    }],\n    3: [function (_dereq_, module, exports) {\n      (function (global) {\n        'use strict';\n\n        if (typeof global.Promise !== 'function') {\n          global.Promise = _dereq_(2);\n        }\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"2\": 2\n    }],\n    4: [function (_dereq_, module, exports) {\n      'use strict';\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      function getIDB() {\n        /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n        try {\n          if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n          }\n          if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n          }\n          if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n          }\n          if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n          }\n          if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n          }\n        } catch (e) {\n          return;\n        }\n      }\n      var idb = getIDB();\n      function isIndexedDBValid() {\n        try {\n          // Initialize IndexedDB; fall back to vendor-prefixed versions\n          // if needed.\n          if (!idb || !idb.open) {\n            return false;\n          }\n          // We mimic PouchDB here;\n          //\n          // We test for openDatabase because IE Mobile identifies itself\n          // as Safari. Oh the lulz...\n          var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n          var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n          // Safari <10.1 does not meet our requirements for IDB support\n          // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n          // Safari 10.1 shipped with fetch, we can use that to detect it.\n          // Note: this creates issues with `window.fetch` polyfills and\n          // overrides; see:\n          // https://github.com/localForage/localForage/issues/856\n          return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n          // some outdated implementations of IDB that appear on Samsung\n          // and HTC Android devices <4.4 are missing IDBKeyRange\n          // See: https://github.com/mozilla/localForage/issues/128\n          // See: https://github.com/mozilla/localForage/issues/272\n          typeof IDBKeyRange !== 'undefined';\n        } catch (e) {\n          return false;\n        }\n      }\n\n      // Abstracts constructing a Blob object, so it also works in older\n      // browsers that don't support the native Blob constructor. (i.e.\n      // old QtWebKit versions, at least).\n      // Abstracts constructing a Blob object, so it also works in older\n      // browsers that don't support the native Blob constructor. (i.e.\n      // old QtWebKit versions, at least).\n      function createBlob(parts, properties) {\n        /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n        parts = parts || [];\n        properties = properties || {};\n        try {\n          return new Blob(parts, properties);\n        } catch (e) {\n          if (e.name !== 'TypeError') {\n            throw e;\n          }\n          var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n          var builder = new Builder();\n          for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n          }\n          return builder.getBlob(properties.type);\n        }\n      }\n\n      // This is CommonJS because lie is an external dependency, so Rollup\n      // can just ignore it.\n      if (typeof Promise === 'undefined') {\n        // In the \"nopromises\" build this will just throw if you don't have\n        // a global promise object, but it would throw anyway later.\n        _dereq_(3);\n      }\n      var Promise$1 = Promise;\n      function executeCallback(promise, callback) {\n        if (callback) {\n          promise.then(function (result) {\n            callback(null, result);\n          }, function (error) {\n            callback(error);\n          });\n        }\n      }\n      function executeTwoCallbacks(promise, callback, errorCallback) {\n        if (typeof callback === 'function') {\n          promise.then(callback);\n        }\n        if (typeof errorCallback === 'function') {\n          promise[\"catch\"](errorCallback);\n        }\n      }\n      function normalizeKey(key) {\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n          console.warn(key + ' used as a key, but it is not a string.');\n          key = String(key);\n        }\n        return key;\n      }\n      function getCallback() {\n        if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n          return arguments[arguments.length - 1];\n        }\n      }\n\n      // Some code originally from async_storage.js in\n      // [Gaia](https://github.com/mozilla-b2g/gaia).\n\n      var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\n      var supportsBlobs = void 0;\n      var dbContexts = {};\n      var toString = Object.prototype.toString;\n\n      // Transaction Modes\n      var READ_ONLY = 'readonly';\n      var READ_WRITE = 'readwrite';\n\n      // Transform a binary string to an array buffer, because otherwise\n      // weird stuff happens when you try to work with the binary string directly.\n      // It is known.\n      // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n      // encode-decode-image-with-base64-breaks-image (2013-04-21)\n      function _binStringToArrayBuffer(bin) {\n        var length = bin.length;\n        var buf = new ArrayBuffer(length);\n        var arr = new Uint8Array(buf);\n        for (var i = 0; i < length; i++) {\n          arr[i] = bin.charCodeAt(i);\n        }\n        return buf;\n      }\n\n      //\n      // Blobs are not supported in all versions of IndexedDB, notably\n      // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n      //\n      // Various other blob bugs exist in Chrome v37-42 (inclusive).\n      // Detecting them is expensive and confusing to users, and Chrome 37-42\n      // is at very low usage worldwide, so we do a hacky userAgent check instead.\n      //\n      // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n      // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n      // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n      //\n      // Code borrowed from PouchDB. See:\n      // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n      //\n      function _checkBlobSupportWithoutCaching(idb) {\n        return new Promise$1(function (resolve) {\n          var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n          var blob = createBlob(['']);\n          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n          txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n          };\n          txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n          };\n        })[\"catch\"](function () {\n          return false; // error, so assume unsupported\n        });\n      }\n      function _checkBlobSupport(idb) {\n        if (typeof supportsBlobs === 'boolean') {\n          return Promise$1.resolve(supportsBlobs);\n        }\n        return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n          supportsBlobs = value;\n          return supportsBlobs;\n        });\n      }\n      function _deferReadiness(dbInfo) {\n        var dbContext = dbContexts[dbInfo.name];\n\n        // Create a deferred object representing the current database operation.\n        var deferredOperation = {};\n        deferredOperation.promise = new Promise$1(function (resolve, reject) {\n          deferredOperation.resolve = resolve;\n          deferredOperation.reject = reject;\n        });\n\n        // Enqueue the deferred operation.\n        dbContext.deferredOperations.push(deferredOperation);\n\n        // Chain its promise to the database readiness.\n        if (!dbContext.dbReady) {\n          dbContext.dbReady = deferredOperation.promise;\n        } else {\n          dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n          });\n        }\n      }\n      function _advanceReadiness(dbInfo) {\n        var dbContext = dbContexts[dbInfo.name];\n\n        // Dequeue a deferred operation.\n        var deferredOperation = dbContext.deferredOperations.pop();\n\n        // Resolve its promise (which is part of the database readiness\n        // chain of promises).\n        if (deferredOperation) {\n          deferredOperation.resolve();\n          return deferredOperation.promise;\n        }\n      }\n      function _rejectReadiness(dbInfo, err) {\n        var dbContext = dbContexts[dbInfo.name];\n\n        // Dequeue a deferred operation.\n        var deferredOperation = dbContext.deferredOperations.pop();\n\n        // Reject its promise (which is part of the database readiness\n        // chain of promises).\n        if (deferredOperation) {\n          deferredOperation.reject(err);\n          return deferredOperation.promise;\n        }\n      }\n      function _getConnection(dbInfo, upgradeNeeded) {\n        return new Promise$1(function (resolve, reject) {\n          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n          if (dbInfo.db) {\n            if (upgradeNeeded) {\n              _deferReadiness(dbInfo);\n              dbInfo.db.close();\n            } else {\n              return resolve(dbInfo.db);\n            }\n          }\n          var dbArgs = [dbInfo.name];\n          if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n          }\n          var openreq = idb.open.apply(idb, dbArgs);\n          if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n              var db = openreq.result;\n              try {\n                db.createObjectStore(dbInfo.storeName);\n                if (e.oldVersion <= 1) {\n                  // Added when support for blob shims was added\n                  db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                }\n              } catch (ex) {\n                if (ex.name === 'ConstraintError') {\n                  console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                } else {\n                  throw ex;\n                }\n              }\n            };\n          }\n          openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n          };\n          openreq.onsuccess = function () {\n            var db = openreq.result;\n            db.onversionchange = function (e) {\n              // Triggered when the database is modified (e.g. adding an objectStore) or\n              // deleted (even when initiated by other sessions in different tabs).\n              // Closing the connection here prevents those operations from being blocked.\n              // If the database is accessed again later by this instance, the connection\n              // will be reopened or the database recreated as needed.\n              e.target.close();\n            };\n            resolve(db);\n            _advanceReadiness(dbInfo);\n          };\n        });\n      }\n      function _getOriginalConnection(dbInfo) {\n        return _getConnection(dbInfo, false);\n      }\n      function _getUpgradedConnection(dbInfo) {\n        return _getConnection(dbInfo, true);\n      }\n      function _isUpgradeNeeded(dbInfo, defaultVersion) {\n        if (!dbInfo.db) {\n          return true;\n        }\n        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n        var isDowngrade = dbInfo.version < dbInfo.db.version;\n        var isUpgrade = dbInfo.version > dbInfo.db.version;\n        if (isDowngrade) {\n          // If the version is not the default one\n          // then warn for impossible downgrade.\n          if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n          }\n          // Align the versions to prevent errors.\n          dbInfo.version = dbInfo.db.version;\n        }\n        if (isUpgrade || isNewStore) {\n          // If the store is new then increment the version (if needed).\n          // This will trigger an \"upgradeneeded\" event which is required\n          // for creating a store.\n          if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n              dbInfo.version = incVersion;\n            }\n          }\n          return true;\n        }\n        return false;\n      }\n\n      // encode a blob for indexeddb engines that don't support blobs\n      function _encodeBlob(blob) {\n        return new Promise$1(function (resolve, reject) {\n          var reader = new FileReader();\n          reader.onerror = reject;\n          reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n              __local_forage_encoded_blob: true,\n              data: base64,\n              type: blob.type\n            });\n          };\n          reader.readAsBinaryString(blob);\n        });\n      }\n\n      // decode an encoded blob\n      function _decodeBlob(encodedBlob) {\n        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n        return createBlob([arrayBuff], {\n          type: encodedBlob.type\n        });\n      }\n\n      // is this one of our fancy encoded blobs?\n      function _isEncodedBlob(value) {\n        return value && value.__local_forage_encoded_blob;\n      }\n\n      // Specialize the default `ready()` function by making it dependent\n      // on the current database operations. Thus, the driver will be actually\n      // ready when it's been initialized (default) *and* there are no pending\n      // operations on the database (initiated by some other instances).\n      function _fullyReady(callback) {\n        var self = this;\n        var promise = self._initReady().then(function () {\n          var dbContext = dbContexts[self._dbInfo.name];\n          if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n          }\n        });\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n      }\n\n      // Try to establish a new db connection to replace the\n      // current one which is broken (i.e. experiencing\n      // InvalidStateError while creating a transaction).\n      function _tryReconnect(dbInfo) {\n        _deferReadiness(dbInfo);\n        var dbContext = dbContexts[dbInfo.name];\n        var forages = dbContext.forages;\n        for (var i = 0; i < forages.length; i++) {\n          var forage = forages[i];\n          if (forage._dbInfo.db) {\n            forage._dbInfo.db.close();\n            forage._dbInfo.db = null;\n          }\n        }\n        dbInfo.db = null;\n        return _getOriginalConnection(dbInfo).then(function (db) {\n          dbInfo.db = db;\n          if (_isUpgradeNeeded(dbInfo)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n          }\n          return db;\n        }).then(function (db) {\n          // store the latest db reference\n          // in case the db was upgraded\n          dbInfo.db = dbContext.db = db;\n          for (var i = 0; i < forages.length; i++) {\n            forages[i]._dbInfo.db = db;\n          }\n        })[\"catch\"](function (err) {\n          _rejectReadiness(dbInfo, err);\n          throw err;\n        });\n      }\n\n      // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n      // so we have to do it with callbacks\n      function createTransaction(dbInfo, mode, callback, retries) {\n        if (retries === undefined) {\n          retries = 1;\n        }\n        try {\n          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n          callback(null, tx);\n        } catch (err) {\n          if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n            return Promise$1.resolve().then(function () {\n              if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                // increase the db version, to create the new ObjectStore\n                if (dbInfo.db) {\n                  dbInfo.version = dbInfo.db.version + 1;\n                }\n                // Reopen the database for upgrading.\n                return _getUpgradedConnection(dbInfo);\n              }\n            }).then(function () {\n              return _tryReconnect(dbInfo).then(function () {\n                createTransaction(dbInfo, mode, callback, retries - 1);\n              });\n            })[\"catch\"](callback);\n          }\n          callback(err);\n        }\n      }\n      function createDbContext() {\n        return {\n          // Running localForages sharing a database.\n          forages: [],\n          // Shared database.\n          db: null,\n          // Database readiness (promise).\n          dbReady: null,\n          // Deferred operations on the database.\n          deferredOperations: []\n        };\n      }\n\n      // Open the IndexedDB database (automatically creates one if one didn't\n      // previously exist), using any options set in the config.\n      function _initStorage(options) {\n        var self = this;\n        var dbInfo = {\n          db: null\n        };\n        if (options) {\n          for (var i in options) {\n            dbInfo[i] = options[i];\n          }\n        }\n\n        // Get the current context of the database;\n        var dbContext = dbContexts[dbInfo.name];\n\n        // ...or create a new context.\n        if (!dbContext) {\n          dbContext = createDbContext();\n          // Register the new context in the global container.\n          dbContexts[dbInfo.name] = dbContext;\n        }\n\n        // Register itself as a running localForage in the current context.\n        dbContext.forages.push(self);\n\n        // Replace the default `ready()` function with the specialized one.\n        if (!self._initReady) {\n          self._initReady = self.ready;\n          self.ready = _fullyReady;\n        }\n\n        // Create an array of initialization states of the related localForages.\n        var initPromises = [];\n        function ignoreErrors() {\n          // Don't handle errors here,\n          // just makes sure related localForages aren't pending.\n          return Promise$1.resolve();\n        }\n        for (var j = 0; j < dbContext.forages.length; j++) {\n          var forage = dbContext.forages[j];\n          if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n          }\n        }\n\n        // Take a snapshot of the related localForages.\n        var forages = dbContext.forages.slice(0);\n\n        // Initialize the connection process only when\n        // all the related localForages aren't pending.\n        return Promise$1.all(initPromises).then(function () {\n          dbInfo.db = dbContext.db;\n          // Get the connection or open a new one without upgrade.\n          return _getOriginalConnection(dbInfo);\n        }).then(function (db) {\n          dbInfo.db = db;\n          if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n          }\n          return db;\n        }).then(function (db) {\n          dbInfo.db = dbContext.db = db;\n          self._dbInfo = dbInfo;\n          // Share the final connection amongst related localForages.\n          for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n              // Self is already up-to-date.\n              forage._dbInfo.db = dbInfo.db;\n              forage._dbInfo.version = dbInfo.version;\n            }\n          }\n        });\n      }\n      function getItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n              if (err) {\n                return reject(err);\n              }\n              try {\n                var store = transaction.objectStore(self._dbInfo.storeName);\n                var req = store.get(key);\n                req.onsuccess = function () {\n                  var value = req.result;\n                  if (value === undefined) {\n                    value = null;\n                  }\n                  if (_isEncodedBlob(value)) {\n                    value = _decodeBlob(value);\n                  }\n                  resolve(value);\n                };\n                req.onerror = function () {\n                  reject(req.error);\n                };\n              } catch (e) {\n                reject(e);\n              }\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Iterate over all items stored in database.\n      function iterate(iterator, callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n              if (err) {\n                return reject(err);\n              }\n              try {\n                var store = transaction.objectStore(self._dbInfo.storeName);\n                var req = store.openCursor();\n                var iterationNumber = 1;\n                req.onsuccess = function () {\n                  var cursor = req.result;\n                  if (cursor) {\n                    var value = cursor.value;\n                    if (_isEncodedBlob(value)) {\n                      value = _decodeBlob(value);\n                    }\n                    var result = iterator(value, cursor.key, iterationNumber++);\n\n                    // when the iterator callback returns any\n                    // (non-`undefined`) value, then we stop\n                    // the iteration immediately\n                    if (result !== void 0) {\n                      resolve(result);\n                    } else {\n                      cursor[\"continue\"]();\n                    }\n                  } else {\n                    resolve();\n                  }\n                };\n                req.onerror = function () {\n                  reject(req.error);\n                };\n              } catch (e) {\n                reject(e);\n              }\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function setItem(key, value, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise$1(function (resolve, reject) {\n          var dbInfo;\n          self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n              return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                if (blobSupport) {\n                  return value;\n                }\n                return _encodeBlob(value);\n              });\n            }\n            return value;\n          }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n              if (err) {\n                return reject(err);\n              }\n              try {\n                var store = transaction.objectStore(self._dbInfo.storeName);\n\n                // The reason we don't _save_ null is because IE 10 does\n                // not support saving the `null` type in IndexedDB. How\n                // ironic, given the bug below!\n                // See: https://github.com/mozilla/localForage/issues/161\n                if (value === null) {\n                  value = undefined;\n                }\n                var req = store.put(value, key);\n                transaction.oncomplete = function () {\n                  // Cast to undefined so the value passed to\n                  // callback/promise is the same as what one would get out\n                  // of `getItem()` later. This leads to some weirdness\n                  // (setItem('foo', undefined) will return `null`), but\n                  // it's not my fault localStorage is our baseline and that\n                  // it's weird.\n                  if (value === undefined) {\n                    value = null;\n                  }\n                  resolve(value);\n                };\n                transaction.onabort = transaction.onerror = function () {\n                  var err = req.error ? req.error : req.transaction.error;\n                  reject(err);\n                };\n              } catch (e) {\n                reject(e);\n              }\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function removeItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n              if (err) {\n                return reject(err);\n              }\n              try {\n                var store = transaction.objectStore(self._dbInfo.storeName);\n                // We use a Grunt task to make this safe for IE and some\n                // versions of Android (including those used by Cordova).\n                // Normally IE won't like `.delete()` and will insist on\n                // using `['delete']()`, but we have a build step that\n                // fixes this for us now.\n                var req = store[\"delete\"](key);\n                transaction.oncomplete = function () {\n                  resolve();\n                };\n                transaction.onerror = function () {\n                  reject(req.error);\n                };\n\n                // The request will be also be aborted if we've exceeded our storage\n                // space.\n                transaction.onabort = function () {\n                  var err = req.error ? req.error : req.transaction.error;\n                  reject(err);\n                };\n              } catch (e) {\n                reject(e);\n              }\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function clear(callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n              if (err) {\n                return reject(err);\n              }\n              try {\n                var store = transaction.objectStore(self._dbInfo.storeName);\n                var req = store.clear();\n                transaction.oncomplete = function () {\n                  resolve();\n                };\n                transaction.onabort = transaction.onerror = function () {\n                  var err = req.error ? req.error : req.transaction.error;\n                  reject(err);\n                };\n              } catch (e) {\n                reject(e);\n              }\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function length(callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n              if (err) {\n                return reject(err);\n              }\n              try {\n                var store = transaction.objectStore(self._dbInfo.storeName);\n                var req = store.count();\n                req.onsuccess = function () {\n                  resolve(req.result);\n                };\n                req.onerror = function () {\n                  reject(req.error);\n                };\n              } catch (e) {\n                reject(e);\n              }\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function key(n, callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          if (n < 0) {\n            resolve(null);\n            return;\n          }\n          self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n              if (err) {\n                return reject(err);\n              }\n              try {\n                var store = transaction.objectStore(self._dbInfo.storeName);\n                var advanced = false;\n                var req = store.openKeyCursor();\n                req.onsuccess = function () {\n                  var cursor = req.result;\n                  if (!cursor) {\n                    // this means there weren't enough keys\n                    resolve(null);\n                    return;\n                  }\n                  if (n === 0) {\n                    // We have the first key, return it if that's what they\n                    // wanted.\n                    resolve(cursor.key);\n                  } else {\n                    if (!advanced) {\n                      // Otherwise, ask the cursor to skip ahead n\n                      // records.\n                      advanced = true;\n                      cursor.advance(n);\n                    } else {\n                      // When we get here, we've got the nth key.\n                      resolve(cursor.key);\n                    }\n                  }\n                };\n                req.onerror = function () {\n                  reject(req.error);\n                };\n              } catch (e) {\n                reject(e);\n              }\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function keys(callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n              if (err) {\n                return reject(err);\n              }\n              try {\n                var store = transaction.objectStore(self._dbInfo.storeName);\n                var req = store.openKeyCursor();\n                var keys = [];\n                req.onsuccess = function () {\n                  var cursor = req.result;\n                  if (!cursor) {\n                    resolve(keys);\n                    return;\n                  }\n                  keys.push(cursor.key);\n                  cursor[\"continue\"]();\n                };\n                req.onerror = function () {\n                  reject(req.error);\n                };\n              } catch (e) {\n                reject(e);\n              }\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function dropInstance(options, callback) {\n        callback = getCallback.apply(this, arguments);\n        var currentConfig = this.config();\n        options = typeof options !== 'function' && options || {};\n        if (!options.name) {\n          options.name = options.name || currentConfig.name;\n          options.storeName = options.storeName || currentConfig.storeName;\n        }\n        var self = this;\n        var promise;\n        if (!options.name) {\n          promise = Promise$1.reject('Invalid arguments');\n        } else {\n          var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n          var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {\n            var dbContext = dbContexts[options.name];\n            var forages = dbContext.forages;\n            dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n              forages[i]._dbInfo.db = db;\n            }\n            return db;\n          });\n          if (!options.storeName) {\n            promise = dbPromise.then(function (db) {\n              _deferReadiness(options);\n              var dbContext = dbContexts[options.name];\n              var forages = dbContext.forages;\n              db.close();\n              for (var i = 0; i < forages.length; i++) {\n                var forage = forages[i];\n                forage._dbInfo.db = null;\n              }\n              var dropDBPromise = new Promise$1(function (resolve, reject) {\n                var req = idb.deleteDatabase(options.name);\n                req.onerror = function () {\n                  var db = req.result;\n                  if (db) {\n                    db.close();\n                  }\n                  reject(req.error);\n                };\n                req.onblocked = function () {\n                  // Closing all open connections in onversionchange handler should prevent this situation, but if\n                  // we do get here, it just means the request remains pending - eventually it will succeed or error\n                  console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                };\n                req.onsuccess = function () {\n                  var db = req.result;\n                  if (db) {\n                    db.close();\n                  }\n                  resolve(db);\n                };\n              });\n              return dropDBPromise.then(function (db) {\n                dbContext.db = db;\n                for (var i = 0; i < forages.length; i++) {\n                  var _forage = forages[i];\n                  _advanceReadiness(_forage._dbInfo);\n                }\n              })[\"catch\"](function (err) {\n                (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                throw err;\n              });\n            });\n          } else {\n            promise = dbPromise.then(function (db) {\n              if (!db.objectStoreNames.contains(options.storeName)) {\n                return;\n              }\n              var newVersion = db.version + 1;\n              _deferReadiness(options);\n              var dbContext = dbContexts[options.name];\n              var forages = dbContext.forages;\n              db.close();\n              for (var i = 0; i < forages.length; i++) {\n                var forage = forages[i];\n                forage._dbInfo.db = null;\n                forage._dbInfo.version = newVersion;\n              }\n              var dropObjectPromise = new Promise$1(function (resolve, reject) {\n                var req = idb.open(options.name, newVersion);\n                req.onerror = function (err) {\n                  var db = req.result;\n                  db.close();\n                  reject(err);\n                };\n                req.onupgradeneeded = function () {\n                  var db = req.result;\n                  db.deleteObjectStore(options.storeName);\n                };\n                req.onsuccess = function () {\n                  var db = req.result;\n                  db.close();\n                  resolve(db);\n                };\n              });\n              return dropObjectPromise.then(function (db) {\n                dbContext.db = db;\n                for (var j = 0; j < forages.length; j++) {\n                  var _forage2 = forages[j];\n                  _forage2._dbInfo.db = db;\n                  _advanceReadiness(_forage2._dbInfo);\n                }\n              })[\"catch\"](function (err) {\n                (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                throw err;\n              });\n            });\n          }\n        }\n        executeCallback(promise, callback);\n        return promise;\n      }\n      var asyncStorage = {\n        _driver: 'asyncStorage',\n        _initStorage: _initStorage,\n        _support: isIndexedDBValid(),\n        iterate: iterate,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys,\n        dropInstance: dropInstance\n      };\n      function isWebSQLValid() {\n        return typeof openDatabase === 'function';\n      }\n\n      // Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n      // it to Base64, so this is how we store it to prevent very strange errors with less\n      // verbose ways of binary <-> string data storage.\n      var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n      var BLOB_TYPE_PREFIX = '~~local_forage_type~';\n      var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n      var SERIALIZED_MARKER = '__lfsc__:';\n      var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n      // OMG the serializations!\n      var TYPE_ARRAYBUFFER = 'arbf';\n      var TYPE_BLOB = 'blob';\n      var TYPE_INT8ARRAY = 'si08';\n      var TYPE_UINT8ARRAY = 'ui08';\n      var TYPE_UINT8CLAMPEDARRAY = 'uic8';\n      var TYPE_INT16ARRAY = 'si16';\n      var TYPE_INT32ARRAY = 'si32';\n      var TYPE_UINT16ARRAY = 'ur16';\n      var TYPE_UINT32ARRAY = 'ui32';\n      var TYPE_FLOAT32ARRAY = 'fl32';\n      var TYPE_FLOAT64ARRAY = 'fl64';\n      var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n      var toString$1 = Object.prototype.toString;\n      function stringToBuffer(serializedString) {\n        // Fill the string into a ArrayBuffer.\n        var bufferLength = serializedString.length * 0.75;\n        var len = serializedString.length;\n        var i;\n        var p = 0;\n        var encoded1, encoded2, encoded3, encoded4;\n        if (serializedString[serializedString.length - 1] === '=') {\n          bufferLength--;\n          if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n          }\n        }\n        var buffer = new ArrayBuffer(bufferLength);\n        var bytes = new Uint8Array(buffer);\n        for (i = 0; i < len; i += 4) {\n          encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n          encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n          encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n          encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n          /*jslint bitwise: true */\n          bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n          bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n          bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n        }\n        return buffer;\n      }\n\n      // Converts a buffer to a string to store, serialized, in the backend\n      // storage library.\n      function bufferToString(buffer) {\n        // base64-arraybuffer\n        var bytes = new Uint8Array(buffer);\n        var base64String = '';\n        var i;\n        for (i = 0; i < bytes.length; i += 3) {\n          /*jslint bitwise: true */\n          base64String += BASE_CHARS[bytes[i] >> 2];\n          base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n          base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n          base64String += BASE_CHARS[bytes[i + 2] & 63];\n        }\n        if (bytes.length % 3 === 2) {\n          base64String = base64String.substring(0, base64String.length - 1) + '=';\n        } else if (bytes.length % 3 === 1) {\n          base64String = base64String.substring(0, base64String.length - 2) + '==';\n        }\n        return base64String;\n      }\n\n      // Serialize a value, afterwards executing a callback (which usually\n      // instructs the `setItem()` callback/promise to be executed). This is how\n      // we store binary data with localStorage.\n      function serialize(value, callback) {\n        var valueType = '';\n        if (value) {\n          valueType = toString$1.call(value);\n        }\n\n        // Cannot use `value instanceof ArrayBuffer` or such here, as these\n        // checks fail when running the tests using casper.js...\n        //\n        // TODO: See why those tests fail and use a better solution.\n        if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n          // Convert binary arrays to a string and prefix the string with\n          // a special marker.\n          var buffer;\n          var marker = SERIALIZED_MARKER;\n          if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n          } else {\n            buffer = value.buffer;\n            if (valueType === '[object Int8Array]') {\n              marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n              marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n              marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n              marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n              marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n              marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n              marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n              marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n              marker += TYPE_FLOAT64ARRAY;\n            } else {\n              callback(new Error('Failed to get type for BinaryArray'));\n            }\n          }\n          callback(marker + bufferToString(buffer));\n        } else if (valueType === '[object Blob]') {\n          // Conver the blob to a binaryArray and then to a string.\n          var fileReader = new FileReader();\n          fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n          };\n          fileReader.readAsArrayBuffer(value);\n        } else {\n          try {\n            callback(JSON.stringify(value));\n          } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n            callback(null, e);\n          }\n        }\n      }\n\n      // Deserialize data we've inserted into a value column/field. We place\n      // special markers into our strings to mark them as encoded; this isn't\n      // as nice as a meta field, but it's the only sane thing we can do whilst\n      // keeping localStorage support intact.\n      //\n      // Oftentimes this will just deserialize JSON content, but if we have a\n      // special marker (SERIALIZED_MARKER, defined above), we will extract\n      // some kind of arraybuffer/binary data/typed array out of the string.\n      function deserialize(value) {\n        // If we haven't marked this string as being specially serialized (i.e.\n        // something other than serialized JSON), we can just return it and be\n        // done with it.\n        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n          return JSON.parse(value);\n        }\n\n        // The following code deals with deserializing some kind of Blob or\n        // TypedArray. First we separate out the type of data we're dealing\n        // with from the data itself.\n        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n        var blobType;\n        // Backwards-compatible blob type serialization strategy.\n        // DBs created with older versions of localForage will simply not have the blob type.\n        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n          blobType = matcher[1];\n          serializedString = serializedString.substring(matcher[0].length);\n        }\n        var buffer = stringToBuffer(serializedString);\n\n        // Return the right type based on the code/type set during\n        // serialization.\n        switch (type) {\n          case TYPE_ARRAYBUFFER:\n            return buffer;\n          case TYPE_BLOB:\n            return createBlob([buffer], {\n              type: blobType\n            });\n          case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n          case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n          case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n          case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n          case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n          case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n          case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n          case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n          case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n          default:\n            throw new Error('Unkown type: ' + type);\n        }\n      }\n      var localforageSerializer = {\n        serialize: serialize,\n        deserialize: deserialize,\n        stringToBuffer: stringToBuffer,\n        bufferToString: bufferToString\n      };\n\n      /*\n       * Includes code from:\n       *\n       * base64-arraybuffer\n       * https://github.com/niklasvh/base64-arraybuffer\n       *\n       * Copyright (c) 2012 Niklas von Hertzen\n       * Licensed under the MIT license.\n       */\n\n      function createDbTable(t, dbInfo, callback, errorCallback) {\n        t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n      }\n\n      // Open the WebSQL database (automatically creates one if one didn't\n      // previously exist), using any options set in the config.\n      function _initStorage$1(options) {\n        var self = this;\n        var dbInfo = {\n          db: null\n        };\n        if (options) {\n          for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n          }\n        }\n        var dbInfoPromise = new Promise$1(function (resolve, reject) {\n          // Open the database; the openDatabase API will automatically\n          // create it for us if it doesn't exist.\n          try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n          } catch (e) {\n            return reject(e);\n          }\n\n          // Create our key/value table if it doesn't exist.\n          dbInfo.db.transaction(function (t) {\n            createDbTable(t, dbInfo, function () {\n              self._dbInfo = dbInfo;\n              resolve();\n            }, function (t, error) {\n              reject(error);\n            });\n          }, reject);\n        });\n        dbInfo.serializer = localforageSerializer;\n        return dbInfoPromise;\n      }\n      function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n        t.executeSql(sqlStatement, args, callback, function (t, error) {\n          if (error.code === error.SYNTAX_ERR) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n              if (!results.rows.length) {\n                // if the table is missing (was deleted)\n                // re-create it table and retry\n                createDbTable(t, dbInfo, function () {\n                  t.executeSql(sqlStatement, args, callback, errorCallback);\n                }, errorCallback);\n              } else {\n                errorCallback(t, error);\n              }\n            }, errorCallback);\n          } else {\n            errorCallback(t, error);\n          }\n        }, errorCallback);\n      }\n      function getItem$1(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n              tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                var result = results.rows.length ? results.rows.item(0).value : null;\n\n                // Check to see if this is serialized content we need to\n                // unpack.\n                if (result) {\n                  result = dbInfo.serializer.deserialize(result);\n                }\n                resolve(result);\n              }, function (t, error) {\n                reject(error);\n              });\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function iterate$1(iterator, callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n              tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                var rows = results.rows;\n                var length = rows.length;\n                for (var i = 0; i < length; i++) {\n                  var item = rows.item(i);\n                  var result = item.value;\n\n                  // Check to see if this is serialized content\n                  // we need to unpack.\n                  if (result) {\n                    result = dbInfo.serializer.deserialize(result);\n                  }\n                  result = iterator(result, item.key, i + 1);\n\n                  // void(0) prevents problems with redefinition\n                  // of `undefined`.\n                  if (result !== void 0) {\n                    resolve(result);\n                    return;\n                  }\n                }\n                resolve();\n              }, function (t, error) {\n                reject(error);\n              });\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function _setItem(key, value, callback, retriesLeft) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n              value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n              if (error) {\n                reject(error);\n              } else {\n                dbInfo.db.transaction(function (t) {\n                  tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {\n                    resolve(originalValue);\n                  }, function (t, error) {\n                    reject(error);\n                  });\n                }, function (sqlError) {\n                  // The transaction failed; check\n                  // to see if it's a quota error.\n                  if (sqlError.code === sqlError.QUOTA_ERR) {\n                    // We reject the callback outright for now, but\n                    // it's worth trying to re-run the transaction.\n                    // Even if the user accepts the prompt to use\n                    // more storage on Safari, this error will\n                    // be called.\n                    //\n                    // Try to re-run the transaction.\n                    if (retriesLeft > 0) {\n                      resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                      return;\n                    }\n                    reject(sqlError);\n                  }\n                });\n              }\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function setItem$1(key, value, callback) {\n        return _setItem.apply(this, [key, value, callback, 1]);\n      }\n      function removeItem$1(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n              tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                resolve();\n              }, function (t, error) {\n                reject(error);\n              });\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Deletes every item in the table.\n      // TODO: Find out if this resets the AUTO_INCREMENT number.\n      function clear$1(callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n              tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {\n                resolve();\n              }, function (t, error) {\n                reject(error);\n              });\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Does a simple `COUNT(key)` to get the number of items stored in\n      // localForage.\n      function length$1(callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n              // Ahhh, SQL makes this one soooooo easy.\n              tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                var result = results.rows.item(0).c;\n                resolve(result);\n              }, function (t, error) {\n                reject(error);\n              });\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Return the key located at key index X; essentially gets the key from a\n      // `WHERE id = ?`. This is the most efficient way I can think to implement\n      // this rarely-used (in my experience) part of the API, but it can seem\n      // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n      // the ID of each key will change every time it's updated. Perhaps a stored\n      // procedure for the `setItem()` SQL would solve this problem?\n      // TODO: Don't change ID on `setItem()`.\n      function key$1(n, callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n              tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                var result = results.rows.length ? results.rows.item(0).key : null;\n                resolve(result);\n              }, function (t, error) {\n                reject(error);\n              });\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function keys$1(callback) {\n        var self = this;\n        var promise = new Promise$1(function (resolve, reject) {\n          self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n              tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                var keys = [];\n                for (var i = 0; i < results.rows.length; i++) {\n                  keys.push(results.rows.item(i).key);\n                }\n                resolve(keys);\n              }, function (t, error) {\n                reject(error);\n              });\n            });\n          })[\"catch\"](reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // https://www.w3.org/TR/webdatabase/#databases\n      // > There is no way to enumerate or delete the databases available for an origin from this API.\n      function getAllStoreNames(db) {\n        return new Promise$1(function (resolve, reject) {\n          db.transaction(function (t) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n              var storeNames = [];\n              for (var i = 0; i < results.rows.length; i++) {\n                storeNames.push(results.rows.item(i).name);\n              }\n              resolve({\n                db: db,\n                storeNames: storeNames\n              });\n            }, function (t, error) {\n              reject(error);\n            });\n          }, function (sqlError) {\n            reject(sqlError);\n          });\n        });\n      }\n      function dropInstance$1(options, callback) {\n        callback = getCallback.apply(this, arguments);\n        var currentConfig = this.config();\n        options = typeof options !== 'function' && options || {};\n        if (!options.name) {\n          options.name = options.name || currentConfig.name;\n          options.storeName = options.storeName || currentConfig.storeName;\n        }\n        var self = this;\n        var promise;\n        if (!options.name) {\n          promise = Promise$1.reject('Invalid arguments');\n        } else {\n          promise = new Promise$1(function (resolve) {\n            var db;\n            if (options.name === currentConfig.name) {\n              // use the db reference of the current instance\n              db = self._dbInfo.db;\n            } else {\n              db = openDatabase(options.name, '', '', 0);\n            }\n            if (!options.storeName) {\n              // drop all database tables\n              resolve(getAllStoreNames(db));\n            } else {\n              resolve({\n                db: db,\n                storeNames: [options.storeName]\n              });\n            }\n          }).then(function (operationInfo) {\n            return new Promise$1(function (resolve, reject) {\n              operationInfo.db.transaction(function (t) {\n                function dropTable(storeName) {\n                  return new Promise$1(function (resolve, reject) {\n                    t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {\n                      resolve();\n                    }, function (t, error) {\n                      reject(error);\n                    });\n                  });\n                }\n                var operations = [];\n                for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                  operations.push(dropTable(operationInfo.storeNames[i]));\n                }\n                Promise$1.all(operations).then(function () {\n                  resolve();\n                })[\"catch\"](function (e) {\n                  reject(e);\n                });\n              }, function (sqlError) {\n                reject(sqlError);\n              });\n            });\n          });\n        }\n        executeCallback(promise, callback);\n        return promise;\n      }\n      var webSQLStorage = {\n        _driver: 'webSQLStorage',\n        _initStorage: _initStorage$1,\n        _support: isWebSQLValid(),\n        iterate: iterate$1,\n        getItem: getItem$1,\n        setItem: setItem$1,\n        removeItem: removeItem$1,\n        clear: clear$1,\n        length: length$1,\n        key: key$1,\n        keys: keys$1,\n        dropInstance: dropInstance$1\n      };\n      function isLocalStorageValid() {\n        try {\n          return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&\n          // in IE8 typeof localStorage.setItem === 'object'\n          !!localStorage.setItem;\n        } catch (e) {\n          return false;\n        }\n      }\n      function _getKeyPrefix(options, defaultConfig) {\n        var keyPrefix = options.name + '/';\n        if (options.storeName !== defaultConfig.storeName) {\n          keyPrefix += options.storeName + '/';\n        }\n        return keyPrefix;\n      }\n\n      // Check if localStorage throws when saving an item\n      function checkIfLocalStorageThrows() {\n        var localStorageTestKey = '_localforage_support_test';\n        try {\n          localStorage.setItem(localStorageTestKey, true);\n          localStorage.removeItem(localStorageTestKey);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n\n      // Check if localStorage is usable and allows to save an item\n      // This method checks if localStorage is usable in Safari Private Browsing\n      // mode, or in any other case where the available quota for localStorage\n      // is 0 and there wasn't any saved items yet.\n      function _isLocalStorageUsable() {\n        return !checkIfLocalStorageThrows() || localStorage.length > 0;\n      }\n\n      // Config the localStorage backend, using options set in the config.\n      function _initStorage$2(options) {\n        var self = this;\n        var dbInfo = {};\n        if (options) {\n          for (var i in options) {\n            dbInfo[i] = options[i];\n          }\n        }\n        dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n        if (!_isLocalStorageUsable()) {\n          return Promise$1.reject();\n        }\n        self._dbInfo = dbInfo;\n        dbInfo.serializer = localforageSerializer;\n        return Promise$1.resolve();\n      }\n\n      // Remove all keys from the datastore, effectively destroying all data in\n      // the app's key/value store!\n      function clear$2(callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n          var keyPrefix = self._dbInfo.keyPrefix;\n          for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) === 0) {\n              localStorage.removeItem(key);\n            }\n          }\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Retrieve an item from the store. Unlike the original async_storage\n      // library in Gaia, we don't modify return values at all. If a key's value\n      // is `undefined`, we pass that value to the callback function.\n      function getItem$2(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = self.ready().then(function () {\n          var dbInfo = self._dbInfo;\n          var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n          // If a result was found, parse it from the serialized\n          // string into a JS object. If result isn't truthy, the key\n          // is likely undefined and we'll pass it straight to the\n          // callback.\n          if (result) {\n            result = dbInfo.serializer.deserialize(result);\n          }\n          return result;\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Iterate over all items in the store.\n      function iterate$2(iterator, callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n          var dbInfo = self._dbInfo;\n          var keyPrefix = dbInfo.keyPrefix;\n          var keyPrefixLength = keyPrefix.length;\n          var length = localStorage.length;\n\n          // We use a dedicated iterator instead of the `i` variable below\n          // so other keys we fetch in localStorage aren't counted in\n          // the `iterationNumber` argument passed to the `iterate()`\n          // callback.\n          //\n          // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n          var iterationNumber = 1;\n          for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n              continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n              value = dbInfo.serializer.deserialize(value);\n            }\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n            if (value !== void 0) {\n              return value;\n            }\n          }\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Same as localStorage's key() method, except takes a callback.\n      function key$2(n, callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n          var dbInfo = self._dbInfo;\n          var result;\n          try {\n            result = localStorage.key(n);\n          } catch (error) {\n            result = null;\n          }\n\n          // Remove the prefix from the key, if a key is found.\n          if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n          }\n          return result;\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function keys$2(callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n          var dbInfo = self._dbInfo;\n          var length = localStorage.length;\n          var keys = [];\n          for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n              keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n          }\n          return keys;\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Supply the number of keys in the datastore to the callback function.\n      function length$2(callback) {\n        var self = this;\n        var promise = self.keys().then(function (keys) {\n          return keys.length;\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Remove an item from the store, nice and simple.\n      function removeItem$2(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = self.ready().then(function () {\n          var dbInfo = self._dbInfo;\n          localStorage.removeItem(dbInfo.keyPrefix + key);\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n\n      // Set a key's value and run an optional callback once the value is set.\n      // Unlike Gaia's implementation, the callback function is passed the value,\n      // in case you want to operate on that value only after you're sure it\n      // saved, or something like that.\n      function setItem$2(key, value, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = self.ready().then(function () {\n          // Convert undefined values to null.\n          // https://github.com/mozilla/localForage/pull/42\n          if (value === undefined) {\n            value = null;\n          }\n\n          // Save the original value to pass to the callback.\n          var originalValue = value;\n          return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n              if (error) {\n                reject(error);\n              } else {\n                try {\n                  localStorage.setItem(dbInfo.keyPrefix + key, value);\n                  resolve(originalValue);\n                } catch (e) {\n                  // localStorage capacity exceeded.\n                  // TODO: Make this a specific error/event.\n                  if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                    reject(e);\n                  }\n                  reject(e);\n                }\n              }\n            });\n          });\n        });\n        executeCallback(promise, callback);\n        return promise;\n      }\n      function dropInstance$2(options, callback) {\n        callback = getCallback.apply(this, arguments);\n        options = typeof options !== 'function' && options || {};\n        if (!options.name) {\n          var currentConfig = this.config();\n          options.name = options.name || currentConfig.name;\n          options.storeName = options.storeName || currentConfig.storeName;\n        }\n        var self = this;\n        var promise;\n        if (!options.name) {\n          promise = Promise$1.reject('Invalid arguments');\n        } else {\n          promise = new Promise$1(function (resolve) {\n            if (!options.storeName) {\n              resolve(options.name + '/');\n            } else {\n              resolve(_getKeyPrefix(options, self._defaultConfig));\n            }\n          }).then(function (keyPrefix) {\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n              var key = localStorage.key(i);\n              if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n              }\n            }\n          });\n        }\n        executeCallback(promise, callback);\n        return promise;\n      }\n      var localStorageWrapper = {\n        _driver: 'localStorageWrapper',\n        _initStorage: _initStorage$2,\n        _support: isLocalStorageValid(),\n        iterate: iterate$2,\n        getItem: getItem$2,\n        setItem: setItem$2,\n        removeItem: removeItem$2,\n        clear: clear$2,\n        length: length$2,\n        key: key$2,\n        keys: keys$2,\n        dropInstance: dropInstance$2\n      };\n      var sameValue = function sameValue(x, y) {\n        return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n      };\n      var includes = function includes(array, searchElement) {\n        var len = array.length;\n        var i = 0;\n        while (i < len) {\n          if (sameValue(array[i], searchElement)) {\n            return true;\n          }\n          i++;\n        }\n        return false;\n      };\n      var isArray = Array.isArray || function (arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n      };\n\n      // Drivers are stored here when `defineDriver()` is called.\n      // They are shared across all instances of localForage.\n      var DefinedDrivers = {};\n      var DriverSupport = {};\n      var DefaultDrivers = {\n        INDEXEDDB: asyncStorage,\n        WEBSQL: webSQLStorage,\n        LOCALSTORAGE: localStorageWrapper\n      };\n      var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n      var OptionalDriverMethods = ['dropInstance'];\n      var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);\n      var DefaultConfig = {\n        description: '',\n        driver: DefaultDriverOrder.slice(),\n        name: 'localforage',\n        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n        // we can use without a prompt.\n        size: 4980736,\n        storeName: 'keyvaluepairs',\n        version: 1.0\n      };\n      function callWhenReady(localForageInstance, libraryMethod) {\n        localForageInstance[libraryMethod] = function () {\n          var _args = arguments;\n          return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n          });\n        };\n      }\n      function extend() {\n        for (var i = 1; i < arguments.length; i++) {\n          var arg = arguments[i];\n          if (arg) {\n            for (var _key in arg) {\n              if (arg.hasOwnProperty(_key)) {\n                if (isArray(arg[_key])) {\n                  arguments[0][_key] = arg[_key].slice();\n                } else {\n                  arguments[0][_key] = arg[_key];\n                }\n              }\n            }\n          }\n        }\n        return arguments[0];\n      }\n      var LocalForage = function () {\n        function LocalForage(options) {\n          _classCallCheck(this, LocalForage);\n          for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n              var driver = DefaultDrivers[driverTypeKey];\n              var driverName = driver._driver;\n              this[driverTypeKey] = driverName;\n              if (!DefinedDrivers[driverName]) {\n                // we don't need to wait for the promise,\n                // since the default drivers can be defined\n                // in a blocking manner\n                this.defineDriver(driver);\n              }\n            }\n          }\n          this._defaultConfig = extend({}, DefaultConfig);\n          this._config = extend({}, this._defaultConfig, options);\n          this._driverSet = null;\n          this._initDriver = null;\n          this._ready = false;\n          this._dbInfo = null;\n          this._wrapLibraryMethodsWithReady();\n          this.setDriver(this._config.driver)[\"catch\"](function () {});\n        }\n\n        // Set any config values for localForage; can be called anytime before\n        // the first API call (e.g. `getItem`, `setItem`).\n        // We loop through options so we don't overwrite existing config\n        // values.\n\n        LocalForage.prototype.config = function config(options) {\n          // If the options argument is an object, we use it to set values.\n          // Otherwise, we return either a specified config value or all\n          // config values.\n          if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n              return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n            for (var i in options) {\n              if (i === 'storeName') {\n                options[i] = options[i].replace(/\\W/g, '_');\n              }\n              if (i === 'version' && typeof options[i] !== 'number') {\n                return new Error('Database version must be a number.');\n              }\n              this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n              return this.setDriver(this._config.driver);\n            }\n            return true;\n          } else if (typeof options === 'string') {\n            return this._config[options];\n          } else {\n            return this._config;\n          }\n        };\n\n        // Used to define a custom driver, shared across all instances of\n        // localForage.\n\n        LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n          var promise = new Promise$1(function (resolve, reject) {\n            try {\n              var driverName = driverObject._driver;\n              var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n              // A driver name should be defined and not overlap with the\n              // library-defined, default drivers.\n              if (!driverObject._driver) {\n                reject(complianceError);\n                return;\n              }\n              var driverMethods = LibraryMethods.concat('_initStorage');\n              for (var i = 0, len = driverMethods.length; i < len; i++) {\n                var driverMethodName = driverMethods[i];\n\n                // when the property is there,\n                // it should be a method even when optional\n                var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                  reject(complianceError);\n                  return;\n                }\n              }\n              var configureMissingMethods = function configureMissingMethods() {\n                var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                  return function () {\n                    var error = new Error('Method ' + methodName + ' is not implemented by the current driver');\n                    var promise = Promise$1.reject(error);\n                    executeCallback(promise, arguments[arguments.length - 1]);\n                    return promise;\n                  };\n                };\n                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {\n                  var optionalDriverMethod = OptionalDriverMethods[_i];\n                  if (!driverObject[optionalDriverMethod]) {\n                    driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                  }\n                }\n              };\n              configureMissingMethods();\n              var setDriverSupport = function setDriverSupport(support) {\n                if (DefinedDrivers[driverName]) {\n                  console.info('Redefining LocalForage driver: ' + driverName);\n                }\n                DefinedDrivers[driverName] = driverObject;\n                DriverSupport[driverName] = support;\n                // don't use a then, so that we can define\n                // drivers that have simple _support methods\n                // in a blocking manner\n                resolve();\n              };\n              if ('_support' in driverObject) {\n                if (driverObject._support && typeof driverObject._support === 'function') {\n                  driverObject._support().then(setDriverSupport, reject);\n                } else {\n                  setDriverSupport(!!driverObject._support);\n                }\n              } else {\n                setDriverSupport(true);\n              }\n            } catch (e) {\n              reject(e);\n            }\n          });\n          executeTwoCallbacks(promise, callback, errorCallback);\n          return promise;\n        };\n        LocalForage.prototype.driver = function driver() {\n          return this._driver || null;\n        };\n        LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n          var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n          executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n          return getDriverPromise;\n        };\n        LocalForage.prototype.getSerializer = function getSerializer(callback) {\n          var serializerPromise = Promise$1.resolve(localforageSerializer);\n          executeTwoCallbacks(serializerPromise, callback);\n          return serializerPromise;\n        };\n        LocalForage.prototype.ready = function ready(callback) {\n          var self = this;\n          var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n              self._ready = self._initDriver();\n            }\n            return self._ready;\n          });\n          executeTwoCallbacks(promise, callback, callback);\n          return promise;\n        };\n        LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n          var self = this;\n          if (!isArray(drivers)) {\n            drivers = [drivers];\n          }\n          var supportedDrivers = this._getSupportedDrivers(drivers);\n          function setDriverToConfig() {\n            self._config.driver = self.driver();\n          }\n          function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n          }\n          function initDriver(supportedDrivers) {\n            return function () {\n              var currentDriverIndex = 0;\n              function driverPromiseLoop() {\n                while (currentDriverIndex < supportedDrivers.length) {\n                  var driverName = supportedDrivers[currentDriverIndex];\n                  currentDriverIndex++;\n                  self._dbInfo = null;\n                  self._ready = null;\n                  return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                }\n                setDriverToConfig();\n                var error = new Error('No available storage method found.');\n                self._driverSet = Promise$1.reject(error);\n                return self._driverSet;\n              }\n              return driverPromiseLoop();\n            };\n          }\n\n          // There might be a driver initialization in progress\n          // so wait for it to finish in order to avoid a possible\n          // race condition to set _dbInfo\n          var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n          }) : Promise$1.resolve();\n          this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n            return self.getDriver(driverName).then(function (driver) {\n              self._driver = driver._driver;\n              setDriverToConfig();\n              self._wrapLibraryMethodsWithReady();\n              self._initDriver = initDriver(supportedDrivers);\n            });\n          })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n          });\n          executeTwoCallbacks(this._driverSet, callback, errorCallback);\n          return this._driverSet;\n        };\n        LocalForage.prototype.supports = function supports(driverName) {\n          return !!DriverSupport[driverName];\n        };\n        LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n          extend(this, libraryMethodsAndProperties);\n        };\n        LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n          var supportedDrivers = [];\n          for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n              supportedDrivers.push(driverName);\n            }\n          }\n          return supportedDrivers;\n        };\n        LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n          // Add a stub for each driver API method that delays the call to the\n          // corresponding driver method until localForage is ready. These stubs\n          // will be replaced by the driver methods as soon as the driver is\n          // loaded, so there is no performance impact.\n          for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n          }\n        };\n        LocalForage.prototype.createInstance = function createInstance(options) {\n          return new LocalForage(options);\n        };\n        return LocalForage;\n      }();\n\n      // The actual localForage object that we expose as a module or via a\n      // global. It's extended by pulling in one of our other libraries.\n\n      var localforage_js = new LocalForage();\n      module.exports = localforage_js;\n    }, {\n      \"3\": 3\n    }]\n  }, {}, [4])(4);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9jYWxmb3JhZ2UvZGlzdC9sb2NhbGZvcmFnZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxVQUFTQSxDQUFDLEVBQUM7RUFBQyxJQUFHLE9BQWMsT0FBQUUsUUFBQSxDQUFQRCxPQUFPLE9BQUcsUUFBUSxJQUFFLFFBQWEsS0FBRyxXQUFXLEVBQUM7SUFBQ0UsTUFBTSxDQUFDRixPQUFPLEdBQUNELENBQUMsQ0FBQyxDQUFDO0VBQUEsQ0FBQyxNQUFLLElBQUcsSUFBc0MsRUFBQztJQUFDSSxpQ0FBTyxFQUFFLG9DQUFDSixDQUFDO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0VBQUEsQ0FBQyxNQUFJLFVBQXdLO0FBQUEsQ0FBQyxFQUFFLFlBQVU7RUFBQyxJQUFJSSxNQUFNLEVBQUNELE1BQU0sRUFBQ0YsT0FBTztFQUFDLE9BQVEsU0FBU1UsQ0FBQ0EsQ0FBQ0MsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUMsRUFBQztJQUFDLFNBQVNDLENBQUNBLENBQUNDLENBQUMsRUFBQ0MsQ0FBQyxFQUFDO01BQUMsSUFBRyxDQUFDSixDQUFDLENBQUNHLENBQUMsQ0FBQyxFQUFDO1FBQUMsSUFBRyxDQUFDSixDQUFDLENBQUNJLENBQUMsQ0FBQyxFQUFDO1VBQUMsSUFBSUUsQ0FBQyxHQUFDLFNBQW1DO1VBQUMsSUFBRyxDQUFDRCxDQUFDLElBQUVDLENBQUMsRUFBQyxPQUFPQSxPQUFDLENBQUNGLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztVQUFDLElBQUdJLENBQUMsRUFBQyxPQUFPQSxDQUFDLENBQUNKLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztVQUFDLElBQUloQixDQUFDLEdBQUMsSUFBSXFCLEtBQUssQ0FBQyxzQkFBc0IsR0FBQ0wsQ0FBQyxHQUFDLEdBQUcsQ0FBQztVQUFDLE1BQU9oQixDQUFDLENBQUNzQixJQUFJLEdBQUMsa0JBQWtCLEVBQUV0QixDQUFDO1FBQUM7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LENBQUMsRUFBQztNQUFDLEdBQUcsRUFBQztJQUFDLENBQUM7RUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvY2FsZm9yYWdlL2Rpc3QvbG9jYWxmb3JhZ2UuanM/Zjg5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgICBsb2NhbEZvcmFnZSAtLSBPZmZsaW5lIFN0b3JhZ2UsIEltcHJvdmVkXG4gICAgVmVyc2lvbiAxLjEwLjBcbiAgICBodHRwczovL2xvY2FsZm9yYWdlLmdpdGh1Yi5pby9sb2NhbEZvcmFnZVxuICAgIChjKSAyMDEzLTIwMTcgTW96aWxsYSwgQXBhY2hlIExpY2Vuc2UgMi4wXG4qL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcubG9jYWxmb3JhZ2UgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgKGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIiwgZil9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxudmFyIHNjaGVkdWxlRHJhaW47XG5cbntcbiAgaWYgKE11dGF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKG5leHRUaWNrKTtcbiAgICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IG5leHRUaWNrO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiBnbG9iYWwgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljaygpO1xuXG4gICAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGljaywgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSBfZGVyZXFfKDEpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gSU5URVJOQUwoKSB7fVxuXG52YXIgaGFuZGxlcnMgPSB7fTtcblxudmFyIFJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xudmFyIEZVTEZJTExFRCA9IFsnRlVMRklMTEVEJ107XG52YXIgUEVORElORyA9IFsnUEVORElORyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3V0Y29tZSA9IHZvaWQgMDtcbiAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCB8fFxuICAgIHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJTlRFUk5BTCk7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgdmFyIHJlc29sdmVyID0gdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuICAgIHVud3JhcChwcm9taXNlLCByZXNvbHZlciwgdGhpcy5vdXRjb21lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5oYW5kbGVycy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgc2VsZi5vdXRjb21lID0gdmFsdWU7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgc2VsZi5xdWV1ZVtpXS5jYWxsRnVsZmlsbGVkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuaGFuZGxlcnMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgc2VsZi5vdXRjb21lID0gZXJyb3I7XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0cnlUb1Vud3JhcCk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgb25FcnJvcihyZXN1bHQudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKG5ldyB0aGlzKElOVEVSTkFMKSwgdmFsdWUpO1xufVxuXG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG4gIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbn0se1wiMVwiOjF9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcbmlmICh0eXBlb2YgZ2xvYmFsLlByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgZ2xvYmFsLlByb21pc2UgPSBfZGVyZXFfKDIpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiMlwiOjJ9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBnZXRJREIoKSB7XG4gICAgLyogZ2xvYmFsIGluZGV4ZWREQix3ZWJraXRJbmRleGVkREIsbW96SW5kZXhlZERCLE9JbmRleGVkREIsbXNJbmRleGVkREIgKi9cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleGVkREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3ZWJraXRJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Via2l0SW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbW96SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG1vekluZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIE9JbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gT0luZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1zSW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG1zSW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG52YXIgaWRiID0gZ2V0SURCKCk7XG5cbmZ1bmN0aW9uIGlzSW5kZXhlZERCVmFsaWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBJbmRleGVkREI7IGZhbGwgYmFjayB0byB2ZW5kb3ItcHJlZml4ZWQgdmVyc2lvbnNcbiAgICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIWlkYiB8fCAhaWRiLm9wZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtaW1pYyBQb3VjaERCIGhlcmU7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHRlc3QgZm9yIG9wZW5EYXRhYmFzZSBiZWNhdXNlIElFIE1vYmlsZSBpZGVudGlmaWVzIGl0c2VsZlxuICAgICAgICAvLyBhcyBTYWZhcmkuIE9oIHRoZSBsdWx6Li4uXG4gICAgICAgIHZhciBpc1NhZmFyaSA9IHR5cGVvZiBvcGVuRGF0YWJhc2UgIT09ICd1bmRlZmluZWQnICYmIC8oU2FmYXJpfGlQaG9uZXxpUGFkfGlQb2QpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvQ2hyb21lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvQmxhY2tCZXJyeS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG4gICAgICAgIHZhciBoYXNGZXRjaCA9IHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiBmZXRjaC50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZScpICE9PSAtMTtcblxuICAgICAgICAvLyBTYWZhcmkgPDEwLjEgZG9lcyBub3QgbWVldCBvdXIgcmVxdWlyZW1lbnRzIGZvciBJREIgc3VwcG9ydFxuICAgICAgICAvLyAoc2VlOiBodHRwczovL2dpdGh1Yi5jb20vcG91Y2hkYi9wb3VjaGRiL2lzc3Vlcy81NTcyKS5cbiAgICAgICAgLy8gU2FmYXJpIDEwLjEgc2hpcHBlZCB3aXRoIGZldGNoLCB3ZSBjYW4gdXNlIHRoYXQgdG8gZGV0ZWN0IGl0LlxuICAgICAgICAvLyBOb3RlOiB0aGlzIGNyZWF0ZXMgaXNzdWVzIHdpdGggYHdpbmRvdy5mZXRjaGAgcG9seWZpbGxzIGFuZFxuICAgICAgICAvLyBvdmVycmlkZXM7IHNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xvY2FsRm9yYWdlL2xvY2FsRm9yYWdlL2lzc3Vlcy84NTZcbiAgICAgICAgcmV0dXJuICghaXNTYWZhcmkgfHwgaGFzRmV0Y2gpICYmIHR5cGVvZiBpbmRleGVkREIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIHNvbWUgb3V0ZGF0ZWQgaW1wbGVtZW50YXRpb25zIG9mIElEQiB0aGF0IGFwcGVhciBvbiBTYW1zdW5nXG4gICAgICAgIC8vIGFuZCBIVEMgQW5kcm9pZCBkZXZpY2VzIDw0LjQgYXJlIG1pc3NpbmcgSURCS2V5UmFuZ2VcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9sb2NhbEZvcmFnZS9pc3N1ZXMvMTI4XG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvaXNzdWVzLzI3MlxuICAgICAgICB0eXBlb2YgSURCS2V5UmFuZ2UgIT09ICd1bmRlZmluZWQnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gQWJzdHJhY3RzIGNvbnN0cnVjdGluZyBhIEJsb2Igb2JqZWN0LCBzbyBpdCBhbHNvIHdvcmtzIGluIG9sZGVyXG4vLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBCbG9iIGNvbnN0cnVjdG9yLiAoaS5lLlxuLy8gb2xkIFF0V2ViS2l0IHZlcnNpb25zLCBhdCBsZWFzdCkuXG4vLyBBYnN0cmFjdHMgY29uc3RydWN0aW5nIGEgQmxvYiBvYmplY3QsIHNvIGl0IGFsc28gd29ya3MgaW4gb2xkZXJcbi8vIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgbmF0aXZlIEJsb2IgY29uc3RydWN0b3IuIChpLmUuXG4vLyBvbGQgUXRXZWJLaXQgdmVyc2lvbnMsIGF0IGxlYXN0KS5cbmZ1bmN0aW9uIGNyZWF0ZUJsb2IocGFydHMsIHByb3BlcnRpZXMpIHtcbiAgICAvKiBnbG9iYWwgQmxvYkJ1aWxkZXIsTVNCbG9iQnVpbGRlcixNb3pCbG9iQnVpbGRlcixXZWJLaXRCbG9iQnVpbGRlciAqL1xuICAgIHBhcnRzID0gcGFydHMgfHwgW107XG4gICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKHBhcnRzLCBwcm9wZXJ0aWVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLm5hbWUgIT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBCdWlsZGVyID0gdHlwZW9mIEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IEJsb2JCdWlsZGVyIDogdHlwZW9mIE1TQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTVNCbG9iQnVpbGRlciA6IHR5cGVvZiBNb3pCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBNb3pCbG9iQnVpbGRlciA6IFdlYktpdEJsb2JCdWlsZGVyO1xuICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKHBhcnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5nZXRCbG9iKHByb3BlcnRpZXMudHlwZSk7XG4gICAgfVxufVxuXG4vLyBUaGlzIGlzIENvbW1vbkpTIGJlY2F1c2UgbGllIGlzIGFuIGV4dGVybmFsIGRlcGVuZGVuY3ksIHNvIFJvbGx1cFxuLy8gY2FuIGp1c3QgaWdub3JlIGl0LlxuaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEluIHRoZSBcIm5vcHJvbWlzZXNcIiBidWlsZCB0aGlzIHdpbGwganVzdCB0aHJvdyBpZiB5b3UgZG9uJ3QgaGF2ZVxuICAgIC8vIGEgZ2xvYmFsIHByb21pc2Ugb2JqZWN0LCBidXQgaXQgd291bGQgdGhyb3cgYW55d2F5IGxhdGVyLlxuICAgIF9kZXJlcV8oMyk7XG59XG52YXIgUHJvbWlzZSQxID0gUHJvbWlzZTtcblxuZnVuY3Rpb24gZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBleGVjdXRlVHdvQ2FsbGJhY2tzKHByb21pc2UsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9taXNlLnRoZW4oY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9taXNlW1wiY2F0Y2hcIl0oZXJyb3JDYWxsYmFjayk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVLZXkoa2V5KSB7XG4gICAgLy8gQ2FzdCB0aGUga2V5IHRvIGEgc3RyaW5nLCBhcyB0aGF0J3MgYWxsIHdlIGNhbiBzZXQgYXMgYSBrZXkuXG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihrZXkgKyAnIHVzZWQgYXMgYSBrZXksIGJ1dCBpdCBpcyBub3QgYSBzdHJpbmcuJyk7XG4gICAgICAgIGtleSA9IFN0cmluZyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIGdldENhbGxiYWNrKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbn1cblxuLy8gU29tZSBjb2RlIG9yaWdpbmFsbHkgZnJvbSBhc3luY19zdG9yYWdlLmpzIGluXG4vLyBbR2FpYV0oaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEtYjJnL2dhaWEpLlxuXG52YXIgREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSA9ICdsb2NhbC1mb3JhZ2UtZGV0ZWN0LWJsb2Itc3VwcG9ydCc7XG52YXIgc3VwcG9ydHNCbG9icyA9IHZvaWQgMDtcbnZhciBkYkNvbnRleHRzID0ge307XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vLyBUcmFuc2FjdGlvbiBNb2Rlc1xudmFyIFJFQURfT05MWSA9ICdyZWFkb25seSc7XG52YXIgUkVBRF9XUklURSA9ICdyZWFkd3JpdGUnO1xuXG4vLyBUcmFuc2Zvcm0gYSBiaW5hcnkgc3RyaW5nIHRvIGFuIGFycmF5IGJ1ZmZlciwgYmVjYXVzZSBvdGhlcndpc2Vcbi8vIHdlaXJkIHN0dWZmIGhhcHBlbnMgd2hlbiB5b3UgdHJ5IHRvIHdvcmsgd2l0aCB0aGUgYmluYXJ5IHN0cmluZyBkaXJlY3RseS5cbi8vIEl0IGlzIGtub3duLlxuLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0OTY3NjQ3LyAoY29udGludWVzIG9uIG5leHQgbGluZSlcbi8vIGVuY29kZS1kZWNvZGUtaW1hZ2Utd2l0aC1iYXNlNjQtYnJlYWtzLWltYWdlICgyMDEzLTA0LTIxKVxuZnVuY3Rpb24gX2JpblN0cmluZ1RvQXJyYXlCdWZmZXIoYmluKSB7XG4gICAgdmFyIGxlbmd0aCA9IGJpbi5sZW5ndGg7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5cbi8vXG4vLyBCbG9icyBhcmUgbm90IHN1cHBvcnRlZCBpbiBhbGwgdmVyc2lvbnMgb2YgSW5kZXhlZERCLCBub3RhYmx5XG4vLyBDaHJvbWUgPDM3IGFuZCBBbmRyb2lkIDw1LiBJbiB0aG9zZSB2ZXJzaW9ucywgc3RvcmluZyBhIGJsb2Igd2lsbCB0aHJvdy5cbi8vXG4vLyBWYXJpb3VzIG90aGVyIGJsb2IgYnVncyBleGlzdCBpbiBDaHJvbWUgdjM3LTQyIChpbmNsdXNpdmUpLlxuLy8gRGV0ZWN0aW5nIHRoZW0gaXMgZXhwZW5zaXZlIGFuZCBjb25mdXNpbmcgdG8gdXNlcnMsIGFuZCBDaHJvbWUgMzctNDJcbi8vIGlzIGF0IHZlcnkgbG93IHVzYWdlIHdvcmxkd2lkZSwgc28gd2UgZG8gYSBoYWNreSB1c2VyQWdlbnQgY2hlY2sgaW5zdGVhZC5cbi8vXG4vLyBjb250ZW50LXR5cGUgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDA4MTIwXG4vLyA0MDQgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3OTE2XG4vLyBGaWxlUmVhZGVyIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzgzNlxuLy9cbi8vIENvZGUgYm9ycm93ZWQgZnJvbSBQb3VjaERCLiBTZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG91Y2hkYi9wb3VjaGRiL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL25vZGVfbW9kdWxlcy9wb3VjaGRiLWFkYXB0ZXItaWRiL3NyYy9ibG9iU3VwcG9ydC5qc1xuLy9cbmZ1bmN0aW9uIF9jaGVja0Jsb2JTdXBwb3J0V2l0aG91dENhY2hpbmcoaWRiKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHR4biA9IGlkYi50cmFuc2FjdGlvbihERVRFQ1RfQkxPQl9TVVBQT1JUX1NUT1JFLCBSRUFEX1dSSVRFKTtcbiAgICAgICAgdmFyIGJsb2IgPSBjcmVhdGVCbG9iKFsnJ10pO1xuICAgICAgICB0eG4ub2JqZWN0U3RvcmUoREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSkucHV0KGJsb2IsICdrZXknKTtcblxuICAgICAgICB0eG4ub25hYm9ydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gYWJvcnRzIG5vdyBpdHMgZHVlIHRvIG5vdCBiZWluZyBhYmxlIHRvXG4gICAgICAgICAgICAvLyB3cml0ZSB0byB0aGUgZGF0YWJhc2UsIGxpa2VseSBkdWUgdG8gdGhlIGRpc2sgYmVpbmcgZnVsbFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWRDaHJvbWUgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkRWRnZSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8vKTtcbiAgICAgICAgICAgIC8vIE1TIEVkZ2UgcHJldGVuZHMgdG8gYmUgQ2hyb21lIDQyOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDg2OTMwMSUyOHY9dnMuODUlMjkuYXNweFxuICAgICAgICAgICAgcmVzb2x2ZShtYXRjaGVkRWRnZSB8fCAhbWF0Y2hlZENocm9tZSB8fCBwYXJzZUludChtYXRjaGVkQ2hyb21lWzFdLCAxMCkgPj0gNDMpO1xuICAgICAgICB9O1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGVycm9yLCBzbyBhc3N1bWUgdW5zdXBwb3J0ZWRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2NoZWNrQmxvYlN1cHBvcnQoaWRiKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBwb3J0c0Jsb2JzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKHN1cHBvcnRzQmxvYnMpO1xuICAgIH1cbiAgICByZXR1cm4gX2NoZWNrQmxvYlN1cHBvcnRXaXRob3V0Q2FjaGluZyhpZGIpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHN1cHBvcnRzQmxvYnMgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzQmxvYnM7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZlclJlYWRpbmVzcyhkYkluZm8pIHtcbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG5cbiAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGRhdGFiYXNlIG9wZXJhdGlvbi5cbiAgICB2YXIgZGVmZXJyZWRPcGVyYXRpb24gPSB7fTtcblxuICAgIGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb24ucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGRlZmVycmVkT3BlcmF0aW9uLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIC8vIEVucXVldWUgdGhlIGRlZmVycmVkIG9wZXJhdGlvbi5cbiAgICBkYkNvbnRleHQuZGVmZXJyZWRPcGVyYXRpb25zLnB1c2goZGVmZXJyZWRPcGVyYXRpb24pO1xuXG4gICAgLy8gQ2hhaW4gaXRzIHByb21pc2UgdG8gdGhlIGRhdGFiYXNlIHJlYWRpbmVzcy5cbiAgICBpZiAoIWRiQ29udGV4dC5kYlJlYWR5KSB7XG4gICAgICAgIGRiQ29udGV4dC5kYlJlYWR5ID0gZGVmZXJyZWRPcGVyYXRpb24ucHJvbWlzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkYkNvbnRleHQuZGJSZWFkeSA9IGRiQ29udGV4dC5kYlJlYWR5LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2FkdmFuY2VSZWFkaW5lc3MoZGJJbmZvKSB7XG4gICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdO1xuXG4gICAgLy8gRGVxdWV1ZSBhIGRlZmVycmVkIG9wZXJhdGlvbi5cbiAgICB2YXIgZGVmZXJyZWRPcGVyYXRpb24gPSBkYkNvbnRleHQuZGVmZXJyZWRPcGVyYXRpb25zLnBvcCgpO1xuXG4gICAgLy8gUmVzb2x2ZSBpdHMgcHJvbWlzZSAod2hpY2ggaXMgcGFydCBvZiB0aGUgZGF0YWJhc2UgcmVhZGluZXNzXG4gICAgLy8gY2hhaW4gb2YgcHJvbWlzZXMpLlxuICAgIGlmIChkZWZlcnJlZE9wZXJhdGlvbikge1xuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbi5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX3JlamVjdFJlYWRpbmVzcyhkYkluZm8sIGVycikge1xuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcblxuICAgIC8vIERlcXVldWUgYSBkZWZlcnJlZCBvcGVyYXRpb24uXG4gICAgdmFyIGRlZmVycmVkT3BlcmF0aW9uID0gZGJDb250ZXh0LmRlZmVycmVkT3BlcmF0aW9ucy5wb3AoKTtcblxuICAgIC8vIFJlamVjdCBpdHMgcHJvbWlzZSAod2hpY2ggaXMgcGFydCBvZiB0aGUgZGF0YWJhc2UgcmVhZGluZXNzXG4gICAgLy8gY2hhaW4gb2YgcHJvbWlzZXMpLlxuICAgIGlmIChkZWZlcnJlZE9wZXJhdGlvbikge1xuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbi5yZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0Q29ubmVjdGlvbihkYkluZm8sIHVwZ3JhZGVOZWVkZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV0gfHwgY3JlYXRlRGJDb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKGRiSW5mby5kYikge1xuICAgICAgICAgICAgaWYgKHVwZ3JhZGVOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICBfZGVmZXJSZWFkaW5lc3MoZGJJbmZvKTtcbiAgICAgICAgICAgICAgICBkYkluZm8uZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGJJbmZvLmRiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYkFyZ3MgPSBbZGJJbmZvLm5hbWVdO1xuXG4gICAgICAgIGlmICh1cGdyYWRlTmVlZGVkKSB7XG4gICAgICAgICAgICBkYkFyZ3MucHVzaChkYkluZm8udmVyc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3BlbnJlcSA9IGlkYi5vcGVuLmFwcGx5KGlkYiwgZGJBcmdzKTtcblxuICAgICAgICBpZiAodXBncmFkZU5lZWRlZCkge1xuICAgICAgICAgICAgb3BlbnJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYiA9IG9wZW5yZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKGRiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vbGRWZXJzaW9uIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZGVkIHdoZW4gc3VwcG9ydCBmb3IgYmxvYiBzaGltcyB3YXMgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09ICdDb25zdHJhaW50RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBkYXRhYmFzZSBcIicgKyBkYkluZm8ubmFtZSArICdcIicgKyAnIGhhcyBiZWVuIHVwZ3JhZGVkIGZyb20gdmVyc2lvbiAnICsgZS5vbGRWZXJzaW9uICsgJyB0byB2ZXJzaW9uICcgKyBlLm5ld1ZlcnNpb24gKyAnLCBidXQgdGhlIHN0b3JhZ2UgXCInICsgZGJJbmZvLnN0b3JlTmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wZW5yZXEub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZWplY3Qob3BlbnJlcS5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3BlbnJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBvcGVucmVxLnJlc3VsdDtcbiAgICAgICAgICAgIGRiLm9udmVyc2lvbmNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIGRhdGFiYXNlIGlzIG1vZGlmaWVkIChlLmcuIGFkZGluZyBhbiBvYmplY3RTdG9yZSkgb3JcbiAgICAgICAgICAgICAgICAvLyBkZWxldGVkIChldmVuIHdoZW4gaW5pdGlhdGVkIGJ5IG90aGVyIHNlc3Npb25zIGluIGRpZmZlcmVudCB0YWJzKS5cbiAgICAgICAgICAgICAgICAvLyBDbG9zaW5nIHRoZSBjb25uZWN0aW9uIGhlcmUgcHJldmVudHMgdGhvc2Ugb3BlcmF0aW9ucyBmcm9tIGJlaW5nIGJsb2NrZWQuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGFiYXNlIGlzIGFjY2Vzc2VkIGFnYWluIGxhdGVyIGJ5IHRoaXMgaW5zdGFuY2UsIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZW9wZW5lZCBvciB0aGUgZGF0YWJhc2UgcmVjcmVhdGVkIGFzIG5lZWRlZC5cbiAgICAgICAgICAgICAgICBlLnRhcmdldC5jbG9zZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICAgICAgX2FkdmFuY2VSZWFkaW5lc3MoZGJJbmZvKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2dldE9yaWdpbmFsQ29ubmVjdGlvbihkYkluZm8pIHtcbiAgICByZXR1cm4gX2dldENvbm5lY3Rpb24oZGJJbmZvLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRVcGdyYWRlZENvbm5lY3Rpb24oZGJJbmZvKSB7XG4gICAgcmV0dXJuIF9nZXRDb25uZWN0aW9uKGRiSW5mbywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIF9pc1VwZ3JhZGVOZWVkZWQoZGJJbmZvLCBkZWZhdWx0VmVyc2lvbikge1xuICAgIGlmICghZGJJbmZvLmRiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc05ld1N0b3JlID0gIWRiSW5mby5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKGRiSW5mby5zdG9yZU5hbWUpO1xuICAgIHZhciBpc0Rvd25ncmFkZSA9IGRiSW5mby52ZXJzaW9uIDwgZGJJbmZvLmRiLnZlcnNpb247XG4gICAgdmFyIGlzVXBncmFkZSA9IGRiSW5mby52ZXJzaW9uID4gZGJJbmZvLmRiLnZlcnNpb247XG5cbiAgICBpZiAoaXNEb3duZ3JhZGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHZlcnNpb24gaXMgbm90IHRoZSBkZWZhdWx0IG9uZVxuICAgICAgICAvLyB0aGVuIHdhcm4gZm9yIGltcG9zc2libGUgZG93bmdyYWRlLlxuICAgICAgICBpZiAoZGJJbmZvLnZlcnNpb24gIT09IGRlZmF1bHRWZXJzaW9uKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBkYXRhYmFzZSBcIicgKyBkYkluZm8ubmFtZSArICdcIicgKyBcIiBjYW4ndCBiZSBkb3duZ3JhZGVkIGZyb20gdmVyc2lvbiBcIiArIGRiSW5mby5kYi52ZXJzaW9uICsgJyB0byB2ZXJzaW9uICcgKyBkYkluZm8udmVyc2lvbiArICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxpZ24gdGhlIHZlcnNpb25zIHRvIHByZXZlbnQgZXJyb3JzLlxuICAgICAgICBkYkluZm8udmVyc2lvbiA9IGRiSW5mby5kYi52ZXJzaW9uO1xuICAgIH1cblxuICAgIGlmIChpc1VwZ3JhZGUgfHwgaXNOZXdTdG9yZSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RvcmUgaXMgbmV3IHRoZW4gaW5jcmVtZW50IHRoZSB2ZXJzaW9uIChpZiBuZWVkZWQpLlxuICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhbiBcInVwZ3JhZGVuZWVkZWRcIiBldmVudCB3aGljaCBpcyByZXF1aXJlZFxuICAgICAgICAvLyBmb3IgY3JlYXRpbmcgYSBzdG9yZS5cbiAgICAgICAgaWYgKGlzTmV3U3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBpbmNWZXJzaW9uID0gZGJJbmZvLmRiLnZlcnNpb24gKyAxO1xuICAgICAgICAgICAgaWYgKGluY1ZlcnNpb24gPiBkYkluZm8udmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGRiSW5mby52ZXJzaW9uID0gaW5jVmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gZW5jb2RlIGEgYmxvYiBmb3IgaW5kZXhlZGRiIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0IGJsb2JzXG5mdW5jdGlvbiBfZW5jb2RlQmxvYihibG9iKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGJhc2U2NCA9IGJ0b2EoZS50YXJnZXQucmVzdWx0IHx8ICcnKTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIF9fbG9jYWxfZm9yYWdlX2VuY29kZWRfYmxvYjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBiYXNlNjQsXG4gICAgICAgICAgICAgICAgdHlwZTogYmxvYi50eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyhibG9iKTtcbiAgICB9KTtcbn1cblxuLy8gZGVjb2RlIGFuIGVuY29kZWQgYmxvYlxuZnVuY3Rpb24gX2RlY29kZUJsb2IoZW5jb2RlZEJsb2IpIHtcbiAgICB2YXIgYXJyYXlCdWZmID0gX2JpblN0cmluZ1RvQXJyYXlCdWZmZXIoYXRvYihlbmNvZGVkQmxvYi5kYXRhKSk7XG4gICAgcmV0dXJuIGNyZWF0ZUJsb2IoW2FycmF5QnVmZl0sIHsgdHlwZTogZW5jb2RlZEJsb2IudHlwZSB9KTtcbn1cblxuLy8gaXMgdGhpcyBvbmUgb2Ygb3VyIGZhbmN5IGVuY29kZWQgYmxvYnM/XG5mdW5jdGlvbiBfaXNFbmNvZGVkQmxvYih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5fX2xvY2FsX2ZvcmFnZV9lbmNvZGVkX2Jsb2I7XG59XG5cbi8vIFNwZWNpYWxpemUgdGhlIGRlZmF1bHQgYHJlYWR5KClgIGZ1bmN0aW9uIGJ5IG1ha2luZyBpdCBkZXBlbmRlbnRcbi8vIG9uIHRoZSBjdXJyZW50IGRhdGFiYXNlIG9wZXJhdGlvbnMuIFRodXMsIHRoZSBkcml2ZXIgd2lsbCBiZSBhY3R1YWxseVxuLy8gcmVhZHkgd2hlbiBpdCdzIGJlZW4gaW5pdGlhbGl6ZWQgKGRlZmF1bHQpICphbmQqIHRoZXJlIGFyZSBubyBwZW5kaW5nXG4vLyBvcGVyYXRpb25zIG9uIHRoZSBkYXRhYmFzZSAoaW5pdGlhdGVkIGJ5IHNvbWUgb3RoZXIgaW5zdGFuY2VzKS5cbmZ1bmN0aW9uIF9mdWxseVJlYWR5KGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLl9pbml0UmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbc2VsZi5fZGJJbmZvLm5hbWVdO1xuXG4gICAgICAgIGlmIChkYkNvbnRleHQgJiYgZGJDb250ZXh0LmRiUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYkNvbnRleHQuZGJSZWFkeTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBUcnkgdG8gZXN0YWJsaXNoIGEgbmV3IGRiIGNvbm5lY3Rpb24gdG8gcmVwbGFjZSB0aGVcbi8vIGN1cnJlbnQgb25lIHdoaWNoIGlzIGJyb2tlbiAoaS5lLiBleHBlcmllbmNpbmdcbi8vIEludmFsaWRTdGF0ZUVycm9yIHdoaWxlIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24pLlxuZnVuY3Rpb24gX3RyeVJlY29ubmVjdChkYkluZm8pIHtcbiAgICBfZGVmZXJSZWFkaW5lc3MoZGJJbmZvKTtcblxuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcbiAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmb3JhZ2UgPSBmb3JhZ2VzW2ldO1xuICAgICAgICBpZiAoZm9yYWdlLl9kYkluZm8uZGIpIHtcbiAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiLmNsb3NlKCk7XG4gICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby5kYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGJJbmZvLmRiID0gbnVsbDtcblxuICAgIHJldHVybiBfZ2V0T3JpZ2luYWxDb25uZWN0aW9uKGRiSW5mbykudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgZGJJbmZvLmRiID0gZGI7XG4gICAgICAgIGlmIChfaXNVcGdyYWRlTmVlZGVkKGRiSW5mbykpIHtcbiAgICAgICAgICAgIC8vIFJlb3BlbiB0aGUgZGF0YWJhc2UgZm9yIHVwZ3JhZGluZy5cbiAgICAgICAgICAgIHJldHVybiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRiO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXRlc3QgZGIgcmVmZXJlbmNlXG4gICAgICAgIC8vIGluIGNhc2UgdGhlIGRiIHdhcyB1cGdyYWRlZFxuICAgICAgICBkYkluZm8uZGIgPSBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3JhZ2VzW2ldLl9kYkluZm8uZGIgPSBkYjtcbiAgICAgICAgfVxuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfcmVqZWN0UmVhZGluZXNzKGRiSW5mbywgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xufVxuXG4vLyBGRiBkb2Vzbid0IGxpa2UgUHJvbWlzZXMgKG1pY3JvLXRhc2tzKSBhbmQgSUREQiBzdG9yZSBvcGVyYXRpb25zLFxuLy8gc28gd2UgaGF2ZSB0byBkbyBpdCB3aXRoIGNhbGxiYWNrc1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb24oZGJJbmZvLCBtb2RlLCBjYWxsYmFjaywgcmV0cmllcykge1xuICAgIGlmIChyZXRyaWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0cmllcyA9IDE7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHR4ID0gZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGRiSW5mby5zdG9yZU5hbWUsIG1vZGUpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0eCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXRyaWVzID4gMCAmJiAoIWRiSW5mby5kYiB8fCBlcnIubmFtZSA9PT0gJ0ludmFsaWRTdGF0ZUVycm9yJyB8fCBlcnIubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYkluZm8uZGIgfHwgZXJyLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJyAmJiAhZGJJbmZvLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoZGJJbmZvLnN0b3JlTmFtZSkgJiYgZGJJbmZvLnZlcnNpb24gPD0gZGJJbmZvLmRiLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGRiIHZlcnNpb24sIHRvIGNyZWF0ZSB0aGUgbmV3IE9iamVjdFN0b3JlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYkluZm8uZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiSW5mby52ZXJzaW9uID0gZGJJbmZvLmRiLnZlcnNpb24gKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlb3BlbiB0aGUgZGF0YWJhc2UgZm9yIHVwZ3JhZGluZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRVcGdyYWRlZENvbm5lY3Rpb24oZGJJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RyeVJlY29ubmVjdChkYkluZm8pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihkYkluZm8sIG1vZGUsIGNhbGxiYWNrLCByZXRyaWVzIC0gMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVtcImNhdGNoXCJdKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEYkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gUnVubmluZyBsb2NhbEZvcmFnZXMgc2hhcmluZyBhIGRhdGFiYXNlLlxuICAgICAgICBmb3JhZ2VzOiBbXSxcbiAgICAgICAgLy8gU2hhcmVkIGRhdGFiYXNlLlxuICAgICAgICBkYjogbnVsbCxcbiAgICAgICAgLy8gRGF0YWJhc2UgcmVhZGluZXNzIChwcm9taXNlKS5cbiAgICAgICAgZGJSZWFkeTogbnVsbCxcbiAgICAgICAgLy8gRGVmZXJyZWQgb3BlcmF0aW9ucyBvbiB0aGUgZGF0YWJhc2UuXG4gICAgICAgIGRlZmVycmVkT3BlcmF0aW9uczogW11cbiAgICB9O1xufVxuXG4vLyBPcGVuIHRoZSBJbmRleGVkREIgZGF0YWJhc2UgKGF1dG9tYXRpY2FsbHkgY3JlYXRlcyBvbmUgaWYgb25lIGRpZG4ndFxuLy8gcHJldmlvdXNseSBleGlzdCksIHVzaW5nIGFueSBvcHRpb25zIHNldCBpbiB0aGUgY29uZmlnLlxuZnVuY3Rpb24gX2luaXRTdG9yYWdlKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRiSW5mbyA9IHtcbiAgICAgICAgZGI6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkYkluZm9baV0gPSBvcHRpb25zW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIGRhdGFiYXNlO1xuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcblxuICAgIC8vIC4uLm9yIGNyZWF0ZSBhIG5ldyBjb250ZXh0LlxuICAgIGlmICghZGJDb250ZXh0KSB7XG4gICAgICAgIGRiQ29udGV4dCA9IGNyZWF0ZURiQ29udGV4dCgpO1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV3IGNvbnRleHQgaW4gdGhlIGdsb2JhbCBjb250YWluZXIuXG4gICAgICAgIGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdID0gZGJDb250ZXh0O1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGl0c2VsZiBhcyBhIHJ1bm5pbmcgbG9jYWxGb3JhZ2UgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICBkYkNvbnRleHQuZm9yYWdlcy5wdXNoKHNlbGYpO1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgZGVmYXVsdCBgcmVhZHkoKWAgZnVuY3Rpb24gd2l0aCB0aGUgc3BlY2lhbGl6ZWQgb25lLlxuICAgIGlmICghc2VsZi5faW5pdFJlYWR5KSB7XG4gICAgICAgIHNlbGYuX2luaXRSZWFkeSA9IHNlbGYucmVhZHk7XG4gICAgICAgIHNlbGYucmVhZHkgPSBfZnVsbHlSZWFkeTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gYXJyYXkgb2YgaW5pdGlhbGl6YXRpb24gc3RhdGVzIG9mIHRoZSByZWxhdGVkIGxvY2FsRm9yYWdlcy5cbiAgICB2YXIgaW5pdFByb21pc2VzID0gW107XG5cbiAgICBmdW5jdGlvbiBpZ25vcmVFcnJvcnMoKSB7XG4gICAgICAgIC8vIERvbid0IGhhbmRsZSBlcnJvcnMgaGVyZSxcbiAgICAgICAgLy8ganVzdCBtYWtlcyBzdXJlIHJlbGF0ZWQgbG9jYWxGb3JhZ2VzIGFyZW4ndCBwZW5kaW5nLlxuICAgICAgICByZXR1cm4gUHJvbWlzZSQxLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRiQ29udGV4dC5mb3JhZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBmb3JhZ2UgPSBkYkNvbnRleHQuZm9yYWdlc1tqXTtcbiAgICAgICAgaWYgKGZvcmFnZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgLy8gRG9uJ3Qgd2FpdCBmb3IgaXRzZWxmLi4uXG4gICAgICAgICAgICBpbml0UHJvbWlzZXMucHVzaChmb3JhZ2UuX2luaXRSZWFkeSgpW1wiY2F0Y2hcIl0oaWdub3JlRXJyb3JzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUYWtlIGEgc25hcHNob3Qgb2YgdGhlIHJlbGF0ZWQgbG9jYWxGb3JhZ2VzLlxuICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXMuc2xpY2UoMCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBjb25uZWN0aW9uIHByb2Nlc3Mgb25seSB3aGVuXG4gICAgLy8gYWxsIHRoZSByZWxhdGVkIGxvY2FsRm9yYWdlcyBhcmVuJ3QgcGVuZGluZy5cbiAgICByZXR1cm4gUHJvbWlzZSQxLmFsbChpbml0UHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBkYkluZm8uZGIgPSBkYkNvbnRleHQuZGI7XG4gICAgICAgIC8vIEdldCB0aGUgY29ubmVjdGlvbiBvciBvcGVuIGEgbmV3IG9uZSB3aXRob3V0IHVwZ3JhZGUuXG4gICAgICAgIHJldHVybiBfZ2V0T3JpZ2luYWxDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgZGJJbmZvLmRiID0gZGI7XG4gICAgICAgIGlmIChfaXNVcGdyYWRlTmVlZGVkKGRiSW5mbywgc2VsZi5fZGVmYXVsdENvbmZpZy52ZXJzaW9uKSkge1xuICAgICAgICAgICAgLy8gUmVvcGVuIHRoZSBkYXRhYmFzZSBmb3IgdXBncmFkaW5nLlxuICAgICAgICAgICAgcmV0dXJuIF9nZXRVcGdyYWRlZENvbm5lY3Rpb24oZGJJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGI7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgZGJJbmZvLmRiID0gZGJDb250ZXh0LmRiID0gZGI7XG4gICAgICAgIHNlbGYuX2RiSW5mbyA9IGRiSW5mbztcbiAgICAgICAgLy8gU2hhcmUgdGhlIGZpbmFsIGNvbm5lY3Rpb24gYW1vbmdzdCByZWxhdGVkIGxvY2FsRm9yYWdlcy5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBmb3JhZ2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgZm9yYWdlID0gZm9yYWdlc1trXTtcbiAgICAgICAgICAgIGlmIChmb3JhZ2UgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWxmIGlzIGFscmVhZHkgdXAtdG8tZGF0ZS5cbiAgICAgICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby5kYiA9IGRiSW5mby5kYjtcbiAgICAgICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby52ZXJzaW9uID0gZGJJbmZvLnZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlbShrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzRW5jb2RlZEJsb2IodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZGVjb2RlQmxvYih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBJdGVyYXRlIG92ZXIgYWxsIGl0ZW1zIHN0b3JlZCBpbiBkYXRhYmFzZS5cbmZ1bmN0aW9uIGl0ZXJhdGUoaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb25OdW1iZXIgPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzRW5jb2RlZEJsb2IodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2RlY29kZUJsb2IodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IodmFsdWUsIGN1cnNvci5rZXksIGl0ZXJhdGlvbk51bWJlcisrKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGl0ZXJhdG9yIGNhbGxiYWNrIHJldHVybnMgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKG5vbi1gdW5kZWZpbmVkYCkgdmFsdWUsIHRoZW4gd2Ugc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVyYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBzZXRJdGVtKGtleSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZGJJbmZvO1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBpZiAodG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEJsb2JdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2hlY2tCbG9iU3VwcG9ydChkYkluZm8uZGIpLnRoZW4oZnVuY3Rpb24gKGJsb2JTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9iU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZW5jb2RlQmxvYih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfV1JJVEUsIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3ZSBkb24ndCBfc2F2ZV8gbnVsbCBpcyBiZWNhdXNlIElFIDEwIGRvZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHN1cHBvcnQgc2F2aW5nIHRoZSBgbnVsbGAgdHlwZSBpbiBJbmRleGVkREIuIEhvd1xuICAgICAgICAgICAgICAgICAgICAvLyBpcm9uaWMsIGdpdmVuIHRoZSBidWcgYmVsb3chXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvaXNzdWVzLzE2MVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLnB1dCh2YWx1ZSwga2V5KTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzdCB0byB1bmRlZmluZWQgc28gdGhlIHZhbHVlIHBhc3NlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGJhY2svcHJvbWlzZSBpcyB0aGUgc2FtZSBhcyB3aGF0IG9uZSB3b3VsZCBnZXQgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBgZ2V0SXRlbSgpYCBsYXRlci4gVGhpcyBsZWFkcyB0byBzb21lIHdlaXJkbmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHNldEl0ZW0oJ2ZvbycsIHVuZGVmaW5lZCkgd2lsbCByZXR1cm4gYG51bGxgKSwgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBteSBmYXVsdCBsb2NhbFN0b3JhZ2UgaXMgb3VyIGJhc2VsaW5lIGFuZCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHdlaXJkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSByZXEuZXJyb3IgPyByZXEuZXJyb3IgOiByZXEudHJhbnNhY3Rpb24uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSXRlbShrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfV1JJVEUsIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhIEdydW50IHRhc2sgdG8gbWFrZSB0aGlzIHNhZmUgZm9yIElFIGFuZCBzb21lXG4gICAgICAgICAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEFuZHJvaWQgKGluY2x1ZGluZyB0aG9zZSB1c2VkIGJ5IENvcmRvdmEpLlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWxseSBJRSB3b24ndCBsaWtlIGAuZGVsZXRlKClgIGFuZCB3aWxsIGluc2lzdCBvblxuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBgWydkZWxldGUnXSgpYCwgYnV0IHdlIGhhdmUgYSBidWlsZCBzdGVwIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZml4ZXMgdGhpcyBmb3IgdXMgbm93LlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmVbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3Qgd2lsbCBiZSBhbHNvIGJlIGFib3J0ZWQgaWYgd2UndmUgZXhjZWVkZWQgb3VyIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gcmVxLmVycm9yID8gcmVxLmVycm9yIDogcmVxLnRyYW5zYWN0aW9uLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGNsZWFyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUuY2xlYXIoKTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uYWJvcnQgPSB0cmFuc2FjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlcS5lcnJvciA/IHJlcS5lcnJvciA6IHJlcS50cmFuc2FjdGlvbi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBsZW5ndGgoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmNvdW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24ga2V5KG4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkdmFuY2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5vcGVuS2V5Q3Vyc29yKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoZXJlIHdlcmVuJ3QgZW5vdWdoIGtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZpcnN0IGtleSwgcmV0dXJuIGl0IGlmIHRoYXQncyB3aGF0IHRoZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YW50ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZHZhbmNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFzayB0aGUgY3Vyc29yIHRvIHNraXAgYWhlYWQgblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNvcmRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UgZ2V0IGhlcmUsIHdlJ3ZlIGdvdCB0aGUgbnRoIGtleS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24ga2V5cyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9PTkxZLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbktleUN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGN1cnNvci5rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yW1wiY29udGludWVcIl0oKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBkcm9wSW5zdGFuY2Uob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGdldENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgY3VycmVudENvbmZpZyA9IHRoaXMuY29uZmlnKCk7XG4gICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IGN1cnJlbnRDb25maWcubmFtZTtcbiAgICAgICAgb3B0aW9ucy5zdG9yZU5hbWUgPSBvcHRpb25zLnN0b3JlTmFtZSB8fCBjdXJyZW50Q29uZmlnLnN0b3JlTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2U7XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZWplY3QoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzQ3VycmVudERiID0gb3B0aW9ucy5uYW1lID09PSBjdXJyZW50Q29uZmlnLm5hbWUgJiYgc2VsZi5fZGJJbmZvLmRiO1xuXG4gICAgICAgIHZhciBkYlByb21pc2UgPSBpc0N1cnJlbnREYiA/IFByb21pc2UkMS5yZXNvbHZlKHNlbGYuX2RiSW5mby5kYikgOiBfZ2V0T3JpZ2luYWxDb25uZWN0aW9uKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tvcHRpb25zLm5hbWVdO1xuICAgICAgICAgICAgdmFyIGZvcmFnZXMgPSBkYkNvbnRleHQuZm9yYWdlcztcbiAgICAgICAgICAgIGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yYWdlc1tpXS5fZGJJbmZvLmRiID0gZGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5zdG9yZU5hbWUpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBkYlByb21pc2UudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgICBfZGVmZXJSZWFkaW5lc3Mob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tvcHRpb25zLm5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXM7XG5cbiAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yYWdlID0gZm9yYWdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkcm9wREJQcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBpZGIuZGVsZXRlRGF0YWJhc2Uob3B0aW9ucy5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsb3NpbmcgYWxsIG9wZW4gY29ubmVjdGlvbnMgaW4gb252ZXJzaW9uY2hhbmdlIGhhbmRsZXIgc2hvdWxkIHByZXZlbnQgdGhpcyBzaXR1YXRpb24sIGJ1dCBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG8gZ2V0IGhlcmUsIGl0IGp1c3QgbWVhbnMgdGhlIHJlcXVlc3QgcmVtYWlucyBwZW5kaW5nIC0gZXZlbnR1YWxseSBpdCB3aWxsIHN1Y2NlZWQgb3IgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZHJvcEluc3RhbmNlIGJsb2NrZWQgZm9yIGRhdGFiYXNlIFwiJyArIG9wdGlvbnMubmFtZSArICdcIiB1bnRpbCBhbGwgb3BlbiBjb25uZWN0aW9ucyBhcmUgY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZHJvcERCUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgICAgICAgICBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ZvcmFnZSA9IGZvcmFnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYWR2YW5jZVJlYWRpbmVzcyhfZm9yYWdlLl9kYkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfcmVqZWN0UmVhZGluZXNzKG9wdGlvbnMsIGVycikgfHwgUHJvbWlzZSQxLnJlc29sdmUoKSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9IGRiUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhvcHRpb25zLnN0b3JlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBuZXdWZXJzaW9uID0gZGIudmVyc2lvbiArIDE7XG5cbiAgICAgICAgICAgICAgICBfZGVmZXJSZWFkaW5lc3Mob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tvcHRpb25zLm5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXM7XG5cbiAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yYWdlID0gZm9yYWdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby52ZXJzaW9uID0gbmV3VmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJvcE9iamVjdFByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYi5vcGVuKG9wdGlvbnMubmFtZSwgbmV3VmVyc2lvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUob3B0aW9ucy5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyb3BPYmplY3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvcmFnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZm9yYWdlMiA9IGZvcmFnZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm9yYWdlMi5fZGJJbmZvLmRiID0gZGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYWR2YW5jZVJlYWRpbmVzcyhfZm9yYWdlMi5fZGJJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAoX3JlamVjdFJlYWRpbmVzcyhvcHRpb25zLCBlcnIpIHx8IFByb21pc2UkMS5yZXNvbHZlKCkpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBhc3luY1N0b3JhZ2UgPSB7XG4gICAgX2RyaXZlcjogJ2FzeW5jU3RvcmFnZScsXG4gICAgX2luaXRTdG9yYWdlOiBfaW5pdFN0b3JhZ2UsXG4gICAgX3N1cHBvcnQ6IGlzSW5kZXhlZERCVmFsaWQoKSxcbiAgICBpdGVyYXRlOiBpdGVyYXRlLFxuICAgIGdldEl0ZW06IGdldEl0ZW0sXG4gICAgc2V0SXRlbTogc2V0SXRlbSxcbiAgICByZW1vdmVJdGVtOiByZW1vdmVJdGVtLFxuICAgIGNsZWFyOiBjbGVhcixcbiAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICBrZXk6IGtleSxcbiAgICBrZXlzOiBrZXlzLFxuICAgIGRyb3BJbnN0YW5jZTogZHJvcEluc3RhbmNlXG59O1xuXG5mdW5jdGlvbiBpc1dlYlNRTFZhbGlkKCkge1xuICAgIHJldHVybiB0eXBlb2Ygb3BlbkRhdGFiYXNlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vLyBTYWRseSwgdGhlIGJlc3Qgd2F5IHRvIHNhdmUgYmluYXJ5IGRhdGEgaW4gV2ViU1FML2xvY2FsU3RvcmFnZSBpcyBzZXJpYWxpemluZ1xuLy8gaXQgdG8gQmFzZTY0LCBzbyB0aGlzIGlzIGhvdyB3ZSBzdG9yZSBpdCB0byBwcmV2ZW50IHZlcnkgc3RyYW5nZSBlcnJvcnMgd2l0aCBsZXNzXG4vLyB2ZXJib3NlIHdheXMgb2YgYmluYXJ5IDwtPiBzdHJpbmcgZGF0YSBzdG9yYWdlLlxudmFyIEJBU0VfQ0hBUlMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbnZhciBCTE9CX1RZUEVfUFJFRklYID0gJ35+bG9jYWxfZm9yYWdlX3R5cGV+JztcbnZhciBCTE9CX1RZUEVfUFJFRklYX1JFR0VYID0gL15+fmxvY2FsX2ZvcmFnZV90eXBlfihbXn5dKyl+LztcblxudmFyIFNFUklBTElaRURfTUFSS0VSID0gJ19fbGZzY19fOic7XG52YXIgU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIID0gU0VSSUFMSVpFRF9NQVJLRVIubGVuZ3RoO1xuXG4vLyBPTUcgdGhlIHNlcmlhbGl6YXRpb25zIVxudmFyIFRZUEVfQVJSQVlCVUZGRVIgPSAnYXJiZic7XG52YXIgVFlQRV9CTE9CID0gJ2Jsb2InO1xudmFyIFRZUEVfSU5UOEFSUkFZID0gJ3NpMDgnO1xudmFyIFRZUEVfVUlOVDhBUlJBWSA9ICd1aTA4JztcbnZhciBUWVBFX1VJTlQ4Q0xBTVBFREFSUkFZID0gJ3VpYzgnO1xudmFyIFRZUEVfSU5UMTZBUlJBWSA9ICdzaTE2JztcbnZhciBUWVBFX0lOVDMyQVJSQVkgPSAnc2kzMic7XG52YXIgVFlQRV9VSU5UMTZBUlJBWSA9ICd1cjE2JztcbnZhciBUWVBFX1VJTlQzMkFSUkFZID0gJ3VpMzInO1xudmFyIFRZUEVfRkxPQVQzMkFSUkFZID0gJ2ZsMzInO1xudmFyIFRZUEVfRkxPQVQ2NEFSUkFZID0gJ2ZsNjQnO1xudmFyIFRZUEVfU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIID0gU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIICsgVFlQRV9BUlJBWUJVRkZFUi5sZW5ndGg7XG5cbnZhciB0b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gc3RyaW5nVG9CdWZmZXIoc2VyaWFsaXplZFN0cmluZykge1xuICAgIC8vIEZpbGwgdGhlIHN0cmluZyBpbnRvIGEgQXJyYXlCdWZmZXIuXG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IHNlcmlhbGl6ZWRTdHJpbmcubGVuZ3RoICogMC43NTtcbiAgICB2YXIgbGVuID0gc2VyaWFsaXplZFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChzZXJpYWxpemVkU3RyaW5nW3NlcmlhbGl6ZWRTdHJpbmcubGVuZ3RoIC0gMV0gPT09ICc9Jykge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRTdHJpbmdbc2VyaWFsaXplZFN0cmluZy5sZW5ndGggLSAyXSA9PT0gJz0nKSB7XG4gICAgICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKTtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGVuY29kZWQxID0gQkFTRV9DSEFSUy5pbmRleE9mKHNlcmlhbGl6ZWRTdHJpbmdbaV0pO1xuICAgICAgICBlbmNvZGVkMiA9IEJBU0VfQ0hBUlMuaW5kZXhPZihzZXJpYWxpemVkU3RyaW5nW2kgKyAxXSk7XG4gICAgICAgIGVuY29kZWQzID0gQkFTRV9DSEFSUy5pbmRleE9mKHNlcmlhbGl6ZWRTdHJpbmdbaSArIDJdKTtcbiAgICAgICAgZW5jb2RlZDQgPSBCQVNFX0NIQVJTLmluZGV4T2Yoc2VyaWFsaXplZFN0cmluZ1tpICsgM10pO1xuXG4gICAgICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cbiAgICAgICAgYnl0ZXNbcCsrXSA9IGVuY29kZWQxIDw8IDIgfCBlbmNvZGVkMiA+PiA0O1xuICAgICAgICBieXRlc1twKytdID0gKGVuY29kZWQyICYgMTUpIDw8IDQgfCBlbmNvZGVkMyA+PiAyO1xuICAgICAgICBieXRlc1twKytdID0gKGVuY29kZWQzICYgMykgPDwgNiB8IGVuY29kZWQ0ICYgNjM7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbi8vIENvbnZlcnRzIGEgYnVmZmVyIHRvIGEgc3RyaW5nIHRvIHN0b3JlLCBzZXJpYWxpemVkLCBpbiB0aGUgYmFja2VuZFxuLy8gc3RvcmFnZSBsaWJyYXJ5LlxuZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoYnVmZmVyKSB7XG4gICAgLy8gYmFzZTY0LWFycmF5YnVmZmVyXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB2YXIgYmFzZTY0U3RyaW5nID0gJyc7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuICAgICAgICBiYXNlNjRTdHJpbmcgKz0gQkFTRV9DSEFSU1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgYmFzZTY0U3RyaW5nICs9IEJBU0VfQ0hBUlNbKGJ5dGVzW2ldICYgMykgPDwgNCB8IGJ5dGVzW2kgKyAxXSA+PiA0XTtcbiAgICAgICAgYmFzZTY0U3RyaW5nICs9IEJBU0VfQ0hBUlNbKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyIHwgYnl0ZXNbaSArIDJdID4+IDZdO1xuICAgICAgICBiYXNlNjRTdHJpbmcgKz0gQkFTRV9DSEFSU1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAlIDMgPT09IDIpIHtcbiAgICAgICAgYmFzZTY0U3RyaW5nID0gYmFzZTY0U3RyaW5nLnN1YnN0cmluZygwLCBiYXNlNjRTdHJpbmcubGVuZ3RoIC0gMSkgKyAnPSc7XG4gICAgfSBlbHNlIGlmIChieXRlcy5sZW5ndGggJSAzID09PSAxKSB7XG4gICAgICAgIGJhc2U2NFN0cmluZyA9IGJhc2U2NFN0cmluZy5zdWJzdHJpbmcoMCwgYmFzZTY0U3RyaW5nLmxlbmd0aCAtIDIpICsgJz09JztcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0U3RyaW5nO1xufVxuXG4vLyBTZXJpYWxpemUgYSB2YWx1ZSwgYWZ0ZXJ3YXJkcyBleGVjdXRpbmcgYSBjYWxsYmFjayAod2hpY2ggdXN1YWxseVxuLy8gaW5zdHJ1Y3RzIHRoZSBgc2V0SXRlbSgpYCBjYWxsYmFjay9wcm9taXNlIHRvIGJlIGV4ZWN1dGVkKS4gVGhpcyBpcyBob3dcbi8vIHdlIHN0b3JlIGJpbmFyeSBkYXRhIHdpdGggbG9jYWxTdG9yYWdlLlxuZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZVR5cGUgPSAnJztcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gdG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgdXNlIGB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyYCBvciBzdWNoIGhlcmUsIGFzIHRoZXNlXG4gICAgLy8gY2hlY2tzIGZhaWwgd2hlbiBydW5uaW5nIHRoZSB0ZXN0cyB1c2luZyBjYXNwZXIuanMuLi5cbiAgICAvL1xuICAgIC8vIFRPRE86IFNlZSB3aHkgdGhvc2UgdGVzdHMgZmFpbCBhbmQgdXNlIGEgYmV0dGVyIHNvbHV0aW9uLlxuICAgIGlmICh2YWx1ZSAmJiAodmFsdWVUeXBlID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nIHx8IHZhbHVlLmJ1ZmZlciAmJiB0b1N0cmluZyQxLmNhbGwodmFsdWUuYnVmZmVyKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykpIHtcbiAgICAgICAgLy8gQ29udmVydCBiaW5hcnkgYXJyYXlzIHRvIGEgc3RyaW5nIGFuZCBwcmVmaXggdGhlIHN0cmluZyB3aXRoXG4gICAgICAgIC8vIGEgc3BlY2lhbCBtYXJrZXIuXG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciBtYXJrZXIgPSBTRVJJQUxJWkVEX01BUktFUjtcblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgYnVmZmVyID0gdmFsdWU7XG4gICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9BUlJBWUJVRkZFUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHZhbHVlLmJ1ZmZlcjtcblxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgSW50OEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9JTlQ4QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgVWludDhBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfVUlOVDhBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfVUlOVDhDTEFNUEVEQVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgSW50MTZBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfSU5UMTZBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfVUlOVDE2QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgSW50MzJBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfSU5UMzJBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBVaW50MzJBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfVUlOVDMyQVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9GTE9BVDMyQVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9GTE9BVDY0QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB0eXBlIGZvciBCaW5hcnlBcnJheScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG1hcmtlciArIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikpO1xuICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBCbG9iXScpIHtcbiAgICAgICAgLy8gQ29udmVyIHRoZSBibG9iIHRvIGEgYmluYXJ5QXJyYXkgYW5kIHRoZW4gdG8gYSBzdHJpbmcuXG4gICAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmxlIHByZWZpeCBmb3IgdGhlIGJsb2IgdHlwZS5cbiAgICAgICAgICAgIHZhciBzdHIgPSBCTE9CX1RZUEVfUFJFRklYICsgdmFsdWUudHlwZSArICd+JyArIGJ1ZmZlclRvU3RyaW5nKHRoaXMucmVzdWx0KTtcblxuICAgICAgICAgICAgY2FsbGJhY2soU0VSSUFMSVpFRF9NQVJLRVIgKyBUWVBFX0JMT0IgKyBzdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWxsYmFjayhKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGRuJ3QgY29udmVydCB2YWx1ZSBpbnRvIGEgSlNPTiBzdHJpbmc6IFwiLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBEZXNlcmlhbGl6ZSBkYXRhIHdlJ3ZlIGluc2VydGVkIGludG8gYSB2YWx1ZSBjb2x1bW4vZmllbGQuIFdlIHBsYWNlXG4vLyBzcGVjaWFsIG1hcmtlcnMgaW50byBvdXIgc3RyaW5ncyB0byBtYXJrIHRoZW0gYXMgZW5jb2RlZDsgdGhpcyBpc24ndFxuLy8gYXMgbmljZSBhcyBhIG1ldGEgZmllbGQsIGJ1dCBpdCdzIHRoZSBvbmx5IHNhbmUgdGhpbmcgd2UgY2FuIGRvIHdoaWxzdFxuLy8ga2VlcGluZyBsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBpbnRhY3QuXG4vL1xuLy8gT2Z0ZW50aW1lcyB0aGlzIHdpbGwganVzdCBkZXNlcmlhbGl6ZSBKU09OIGNvbnRlbnQsIGJ1dCBpZiB3ZSBoYXZlIGFcbi8vIHNwZWNpYWwgbWFya2VyIChTRVJJQUxJWkVEX01BUktFUiwgZGVmaW5lZCBhYm92ZSksIHdlIHdpbGwgZXh0cmFjdFxuLy8gc29tZSBraW5kIG9mIGFycmF5YnVmZmVyL2JpbmFyeSBkYXRhL3R5cGVkIGFycmF5IG91dCBvZiB0aGUgc3RyaW5nLlxuZnVuY3Rpb24gZGVzZXJpYWxpemUodmFsdWUpIHtcbiAgICAvLyBJZiB3ZSBoYXZlbid0IG1hcmtlZCB0aGlzIHN0cmluZyBhcyBiZWluZyBzcGVjaWFsbHkgc2VyaWFsaXplZCAoaS5lLlxuICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuIHNlcmlhbGl6ZWQgSlNPTiksIHdlIGNhbiBqdXN0IHJldHVybiBpdCBhbmQgYmVcbiAgICAvLyBkb25lIHdpdGggaXQuXG4gICAgaWYgKHZhbHVlLnN1YnN0cmluZygwLCBTRVJJQUxJWkVEX01BUktFUl9MRU5HVEgpICE9PSBTRVJJQUxJWkVEX01BUktFUikge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGRlYWxzIHdpdGggZGVzZXJpYWxpemluZyBzb21lIGtpbmQgb2YgQmxvYiBvclxuICAgIC8vIFR5cGVkQXJyYXkuIEZpcnN0IHdlIHNlcGFyYXRlIG91dCB0aGUgdHlwZSBvZiBkYXRhIHdlJ3JlIGRlYWxpbmdcbiAgICAvLyB3aXRoIGZyb20gdGhlIGRhdGEgaXRzZWxmLlxuICAgIHZhciBzZXJpYWxpemVkU3RyaW5nID0gdmFsdWUuc3Vic3RyaW5nKFRZUEVfU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIKTtcbiAgICB2YXIgdHlwZSA9IHZhbHVlLnN1YnN0cmluZyhTRVJJQUxJWkVEX01BUktFUl9MRU5HVEgsIFRZUEVfU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIKTtcblxuICAgIHZhciBibG9iVHlwZTtcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJsZSBibG9iIHR5cGUgc2VyaWFsaXphdGlvbiBzdHJhdGVneS5cbiAgICAvLyBEQnMgY3JlYXRlZCB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGxvY2FsRm9yYWdlIHdpbGwgc2ltcGx5IG5vdCBoYXZlIHRoZSBibG9iIHR5cGUuXG4gICAgaWYgKHR5cGUgPT09IFRZUEVfQkxPQiAmJiBCTE9CX1RZUEVfUFJFRklYX1JFR0VYLnRlc3Qoc2VyaWFsaXplZFN0cmluZykpIHtcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBzZXJpYWxpemVkU3RyaW5nLm1hdGNoKEJMT0JfVFlQRV9QUkVGSVhfUkVHRVgpO1xuICAgICAgICBibG9iVHlwZSA9IG1hdGNoZXJbMV07XG4gICAgICAgIHNlcmlhbGl6ZWRTdHJpbmcgPSBzZXJpYWxpemVkU3RyaW5nLnN1YnN0cmluZyhtYXRjaGVyWzBdLmxlbmd0aCk7XG4gICAgfVxuICAgIHZhciBidWZmZXIgPSBzdHJpbmdUb0J1ZmZlcihzZXJpYWxpemVkU3RyaW5nKTtcblxuICAgIC8vIFJldHVybiB0aGUgcmlnaHQgdHlwZSBiYXNlZCBvbiB0aGUgY29kZS90eXBlIHNldCBkdXJpbmdcbiAgICAvLyBzZXJpYWxpemF0aW9uLlxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFRZUEVfQVJSQVlCVUZGRVI6XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICBjYXNlIFRZUEVfQkxPQjpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVCbG9iKFtidWZmZXJdLCB7IHR5cGU6IGJsb2JUeXBlIH0pO1xuICAgICAgICBjYXNlIFRZUEVfSU5UOEFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX1VJTlQ4QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX1VJTlQ4Q0xBTVBFREFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfSU5UMTZBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfVUlOVDE2QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9JTlQzMkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9VSU5UMzJBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX0ZMT0FUMzJBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9GTE9BVDY0QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShidWZmZXIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtvd24gdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbn1cblxudmFyIGxvY2FsZm9yYWdlU2VyaWFsaXplciA9IHtcbiAgICBzZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICBkZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgc3RyaW5nVG9CdWZmZXI6IHN0cmluZ1RvQnVmZmVyLFxuICAgIGJ1ZmZlclRvU3RyaW5nOiBidWZmZXJUb1N0cmluZ1xufTtcblxuLypcbiAqIEluY2x1ZGVzIGNvZGUgZnJvbTpcbiAqXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGJUYWJsZSh0LCBkYkluZm8sIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdC5leGVjdXRlU3FsKCdDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgJyArICcoaWQgSU5URUdFUiBQUklNQVJZIEtFWSwga2V5IHVuaXF1ZSwgdmFsdWUpJywgW10sIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbn1cblxuLy8gT3BlbiB0aGUgV2ViU1FMIGRhdGFiYXNlIChhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgb25lIGlmIG9uZSBkaWRuJ3Rcbi8vIHByZXZpb3VzbHkgZXhpc3QpLCB1c2luZyBhbnkgb3B0aW9ucyBzZXQgaW4gdGhlIGNvbmZpZy5cbmZ1bmN0aW9uIF9pbml0U3RvcmFnZSQxKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRiSW5mbyA9IHtcbiAgICAgICAgZGI6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkYkluZm9baV0gPSB0eXBlb2Ygb3B0aW9uc1tpXSAhPT0gJ3N0cmluZycgPyBvcHRpb25zW2ldLnRvU3RyaW5nKCkgOiBvcHRpb25zW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRiSW5mb1Byb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gT3BlbiB0aGUgZGF0YWJhc2U7IHRoZSBvcGVuRGF0YWJhc2UgQVBJIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAgICAvLyBjcmVhdGUgaXQgZm9yIHVzIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYkluZm8uZGIgPSBvcGVuRGF0YWJhc2UoZGJJbmZvLm5hbWUsIFN0cmluZyhkYkluZm8udmVyc2lvbiksIGRiSW5mby5kZXNjcmlwdGlvbiwgZGJJbmZvLnNpemUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIG91ciBrZXkvdmFsdWUgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBjcmVhdGVEYlRhYmxlKHQsIGRiSW5mbywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2RiSW5mbyA9IGRiSW5mbztcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBkYkluZm8uc2VyaWFsaXplciA9IGxvY2FsZm9yYWdlU2VyaWFsaXplcjtcbiAgICByZXR1cm4gZGJJbmZvUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sIHNxbFN0YXRlbWVudCwgYXJncywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICB0LmV4ZWN1dGVTcWwoc3FsU3RhdGVtZW50LCBhcmdzLCBjYWxsYmFjaywgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBlcnJvci5TWU5UQVhfRVJSKSB7XG4gICAgICAgICAgICB0LmV4ZWN1dGVTcWwoJ1NFTEVDVCBuYW1lIEZST00gc3FsaXRlX21hc3RlciAnICsgXCJXSEVSRSB0eXBlPSd0YWJsZScgQU5EIG5hbWUgPSA/XCIsIFtkYkluZm8uc3RvcmVOYW1lXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMucm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRhYmxlIGlzIG1pc3NpbmcgKHdhcyBkZWxldGVkKVxuICAgICAgICAgICAgICAgICAgICAvLyByZS1jcmVhdGUgaXQgdGFibGUgYW5kIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZURiVGFibGUodCwgZGJJbmZvLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LmV4ZWN1dGVTcWwoc3FsU3RhdGVtZW50LCBhcmdzLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2sodCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayh0LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9LCBlcnJvckNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlbSQxKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCAqIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnIFdIRVJFIGtleSA9ID8gTElNSVQgMScsIFtrZXldLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0cy5yb3dzLmxlbmd0aCA/IHJlc3VsdHMucm93cy5pdGVtKDApLnZhbHVlIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBpcyBzZXJpYWxpemVkIGNvbnRlbnQgd2UgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB1bnBhY2suXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRiSW5mby5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gaXRlcmF0ZSQxKGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG5cbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUICogRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gcmVzdWx0cy5yb3dzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gcm93cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSByb3dzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlbS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgc2VyaWFsaXplZCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHVucGFjay5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvcihyZXN1bHQsIGl0ZW0ua2V5LCBpICsgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZvaWQoMCkgcHJldmVudHMgcHJvYmxlbXMgd2l0aCByZWRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGB1bmRlZmluZWRgLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBfc2V0SXRlbShrZXksIHZhbHVlLCBjYWxsYmFjaywgcmV0cmllc0xlZnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBsb2NhbFN0b3JhZ2UgQVBJIGRvZXNuJ3QgcmV0dXJuIHVuZGVmaW5lZCB2YWx1ZXMgaW4gYW5cbiAgICAgICAgICAgIC8vIFwiZXhwZWN0ZWRcIiB3YXksIHNvIHVuZGVmaW5lZCBpcyBhbHdheXMgY2FzdCB0byBudWxsIGluIGFsbFxuICAgICAgICAgICAgLy8gZHJpdmVycy4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9sb2NhbEZvcmFnZS9wdWxsLzQyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgb3JpZ2luYWwgdmFsdWUgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ0lOU0VSVCBPUiBSRVBMQUNFIElOVE8gJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnICcgKyAnKGtleSwgdmFsdWUpIFZBTFVFUyAoPywgPyknLCBba2V5LCB2YWx1ZV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9yaWdpbmFsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoc3FsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0cmFuc2FjdGlvbiBmYWlsZWQ7IGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBzZWUgaWYgaXQncyBhIHF1b3RhIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNxbEVycm9yLmNvZGUgPT09IHNxbEVycm9yLlFVT1RBX0VSUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHJlamVjdCB0aGUgY2FsbGJhY2sgb3V0cmlnaHQgZm9yIG5vdywgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyB3b3J0aCB0cnlpbmcgdG8gcmUtcnVuIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB1c2VyIGFjY2VwdHMgdGhlIHByb21wdCB0byB1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIHN0b3JhZ2Ugb24gU2FmYXJpLCB0aGlzIGVycm9yIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSBjYWxsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcmUtcnVuIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0cmllc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3NldEl0ZW0uYXBwbHkoc2VsZiwgW2tleSwgb3JpZ2luYWxWYWx1ZSwgY2FsbGJhY2ssIHJldHJpZXNMZWZ0IC0gMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3FsRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gc2V0SXRlbSQxKGtleSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9zZXRJdGVtLmFwcGx5KHRoaXMsIFtrZXksIHZhbHVlLCBjYWxsYmFjaywgMV0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVJdGVtJDEoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnREVMRVRFIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnIFdIRVJFIGtleSA9ID8nLCBba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gRGVsZXRlcyBldmVyeSBpdGVtIGluIHRoZSB0YWJsZS5cbi8vIFRPRE86IEZpbmQgb3V0IGlmIHRoaXMgcmVzZXRzIHRoZSBBVVRPX0lOQ1JFTUVOVCBudW1iZXIuXG5mdW5jdGlvbiBjbGVhciQxKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnREVMRVRFIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBEb2VzIGEgc2ltcGxlIGBDT1VOVChrZXkpYCB0byBnZXQgdGhlIG51bWJlciBvZiBpdGVtcyBzdG9yZWQgaW5cbi8vIGxvY2FsRm9yYWdlLlxuZnVuY3Rpb24gbGVuZ3RoJDEoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgLy8gQWhoaCwgU1FMIG1ha2VzIHRoaXMgb25lIHNvb29vb28gZWFzeS5cbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCBDT1VOVChrZXkpIGFzIGMgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzLnJvd3MuaXRlbSgwKS5jO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gUmV0dXJuIHRoZSBrZXkgbG9jYXRlZCBhdCBrZXkgaW5kZXggWDsgZXNzZW50aWFsbHkgZ2V0cyB0aGUga2V5IGZyb20gYVxuLy8gYFdIRVJFIGlkID0gP2AuIFRoaXMgaXMgdGhlIG1vc3QgZWZmaWNpZW50IHdheSBJIGNhbiB0aGluayB0byBpbXBsZW1lbnRcbi8vIHRoaXMgcmFyZWx5LXVzZWQgKGluIG15IGV4cGVyaWVuY2UpIHBhcnQgb2YgdGhlIEFQSSwgYnV0IGl0IGNhbiBzZWVtXG4vLyBpbmNvbnNpc3RlbnQsIGJlY2F1c2Ugd2UgZG8gYElOU0VSVCBPUiBSRVBMQUNFIElOVE9gIG9uIGBzZXRJdGVtKClgLCBzb1xuLy8gdGhlIElEIG9mIGVhY2gga2V5IHdpbGwgY2hhbmdlIGV2ZXJ5IHRpbWUgaXQncyB1cGRhdGVkLiBQZXJoYXBzIGEgc3RvcmVkXG4vLyBwcm9jZWR1cmUgZm9yIHRoZSBgc2V0SXRlbSgpYCBTUUwgd291bGQgc29sdmUgdGhpcyBwcm9ibGVtP1xuLy8gVE9ETzogRG9uJ3QgY2hhbmdlIElEIG9uIGBzZXRJdGVtKClgLlxuZnVuY3Rpb24ga2V5JDEobiwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1Qga2V5IEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnIFdIRVJFIGlkID0gPyBMSU1JVCAxJywgW24gKyAxXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHMucm93cy5sZW5ndGggPyByZXN1bHRzLnJvd3MuaXRlbSgwKS5rZXkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24ga2V5cyQxKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUIGtleSBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHJlc3VsdHMucm93cy5pdGVtKGkpLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGtleXMpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJkYXRhYmFzZS8jZGF0YWJhc2VzXG4vLyA+IFRoZXJlIGlzIG5vIHdheSB0byBlbnVtZXJhdGUgb3IgZGVsZXRlIHRoZSBkYXRhYmFzZXMgYXZhaWxhYmxlIGZvciBhbiBvcmlnaW4gZnJvbSB0aGlzIEFQSS5cbmZ1bmN0aW9uIGdldEFsbFN0b3JlTmFtZXMoZGIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0LmV4ZWN1dGVTcWwoJ1NFTEVDVCBuYW1lIEZST00gc3FsaXRlX21hc3RlciAnICsgXCJXSEVSRSB0eXBlPSd0YWJsZScgQU5EIG5hbWUgPD4gJ19fV2ViS2l0RGF0YWJhc2VJbmZvVGFibGVfXydcIiwgW10sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlTmFtZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMucHVzaChyZXN1bHRzLnJvd3MuaXRlbShpKS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgZGI6IGRiLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzOiBzdG9yZU5hbWVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChzcWxFcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KHNxbEVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGRyb3BJbnN0YW5jZSQxKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBjdXJyZW50Q29uZmlnLm5hbWU7XG4gICAgICAgIG9wdGlvbnMuc3RvcmVOYW1lID0gb3B0aW9ucy5zdG9yZU5hbWUgfHwgY3VycmVudENvbmZpZy5zdG9yZU5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICB2YXIgZGI7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5uYW1lID09PSBjdXJyZW50Q29uZmlnLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGRiIHJlZmVyZW5jZSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGRiID0gc2VsZi5fZGJJbmZvLmRiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYiA9IG9wZW5EYXRhYmFzZShvcHRpb25zLm5hbWUsICcnLCAnJywgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBkcm9wIGFsbCBkYXRhYmFzZSB0YWJsZXNcbiAgICAgICAgICAgICAgICByZXNvbHZlKGdldEFsbFN0b3JlTmFtZXMoZGIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRiOiBkYixcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lczogW29wdGlvbnMuc3RvcmVOYW1lXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChvcGVyYXRpb25JbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkcm9wVGFibGUoc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5leGVjdXRlU3FsKCdEUk9QIFRBQkxFIElGIEVYSVNUUyAnICsgc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcGVyYXRpb25JbmZvLnN0b3JlTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChkcm9wVGFibGUob3BlcmF0aW9uSW5mby5zdG9yZU5hbWVzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlJDEuYWxsKG9wZXJhdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChzcWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3FsRXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciB3ZWJTUUxTdG9yYWdlID0ge1xuICAgIF9kcml2ZXI6ICd3ZWJTUUxTdG9yYWdlJyxcbiAgICBfaW5pdFN0b3JhZ2U6IF9pbml0U3RvcmFnZSQxLFxuICAgIF9zdXBwb3J0OiBpc1dlYlNRTFZhbGlkKCksXG4gICAgaXRlcmF0ZTogaXRlcmF0ZSQxLFxuICAgIGdldEl0ZW06IGdldEl0ZW0kMSxcbiAgICBzZXRJdGVtOiBzZXRJdGVtJDEsXG4gICAgcmVtb3ZlSXRlbTogcmVtb3ZlSXRlbSQxLFxuICAgIGNsZWFyOiBjbGVhciQxLFxuICAgIGxlbmd0aDogbGVuZ3RoJDEsXG4gICAga2V5OiBrZXkkMSxcbiAgICBrZXlzOiBrZXlzJDEsXG4gICAgZHJvcEluc3RhbmNlOiBkcm9wSW5zdGFuY2UkMVxufTtcblxuZnVuY3Rpb24gaXNMb2NhbFN0b3JhZ2VWYWxpZCgpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3NldEl0ZW0nIGluIGxvY2FsU3RvcmFnZSAmJlxuICAgICAgICAvLyBpbiBJRTggdHlwZW9mIGxvY2FsU3RvcmFnZS5zZXRJdGVtID09PSAnb2JqZWN0J1xuICAgICAgICAhIWxvY2FsU3RvcmFnZS5zZXRJdGVtO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2dldEtleVByZWZpeChvcHRpb25zLCBkZWZhdWx0Q29uZmlnKSB7XG4gICAgdmFyIGtleVByZWZpeCA9IG9wdGlvbnMubmFtZSArICcvJztcblxuICAgIGlmIChvcHRpb25zLnN0b3JlTmFtZSAhPT0gZGVmYXVsdENvbmZpZy5zdG9yZU5hbWUpIHtcbiAgICAgICAga2V5UHJlZml4ICs9IG9wdGlvbnMuc3RvcmVOYW1lICsgJy8nO1xuICAgIH1cbiAgICByZXR1cm4ga2V5UHJlZml4O1xufVxuXG4vLyBDaGVjayBpZiBsb2NhbFN0b3JhZ2UgdGhyb3dzIHdoZW4gc2F2aW5nIGFuIGl0ZW1cbmZ1bmN0aW9uIGNoZWNrSWZMb2NhbFN0b3JhZ2VUaHJvd3MoKSB7XG4gICAgdmFyIGxvY2FsU3RvcmFnZVRlc3RLZXkgPSAnX2xvY2FsZm9yYWdlX3N1cHBvcnRfdGVzdCc7XG5cbiAgICB0cnkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VUZXN0S2V5LCB0cnVlKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obG9jYWxTdG9yYWdlVGVzdEtleSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vLyBDaGVjayBpZiBsb2NhbFN0b3JhZ2UgaXMgdXNhYmxlIGFuZCBhbGxvd3MgdG8gc2F2ZSBhbiBpdGVtXG4vLyBUaGlzIG1ldGhvZCBjaGVja3MgaWYgbG9jYWxTdG9yYWdlIGlzIHVzYWJsZSBpbiBTYWZhcmkgUHJpdmF0ZSBCcm93c2luZ1xuLy8gbW9kZSwgb3IgaW4gYW55IG90aGVyIGNhc2Ugd2hlcmUgdGhlIGF2YWlsYWJsZSBxdW90YSBmb3IgbG9jYWxTdG9yYWdlXG4vLyBpcyAwIGFuZCB0aGVyZSB3YXNuJ3QgYW55IHNhdmVkIGl0ZW1zIHlldC5cbmZ1bmN0aW9uIF9pc0xvY2FsU3RvcmFnZVVzYWJsZSgpIHtcbiAgICByZXR1cm4gIWNoZWNrSWZMb2NhbFN0b3JhZ2VUaHJvd3MoKSB8fCBsb2NhbFN0b3JhZ2UubGVuZ3RoID4gMDtcbn1cblxuLy8gQ29uZmlnIHRoZSBsb2NhbFN0b3JhZ2UgYmFja2VuZCwgdXNpbmcgb3B0aW9ucyBzZXQgaW4gdGhlIGNvbmZpZy5cbmZ1bmN0aW9uIF9pbml0U3RvcmFnZSQyKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRiSW5mbyA9IHt9O1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGJJbmZvW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRiSW5mby5rZXlQcmVmaXggPSBfZ2V0S2V5UHJlZml4KG9wdGlvbnMsIHNlbGYuX2RlZmF1bHRDb25maWcpO1xuXG4gICAgaWYgKCFfaXNMb2NhbFN0b3JhZ2VVc2FibGUoKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZSQxLnJlamVjdCgpO1xuICAgIH1cblxuICAgIHNlbGYuX2RiSW5mbyA9IGRiSW5mbztcbiAgICBkYkluZm8uc2VyaWFsaXplciA9IGxvY2FsZm9yYWdlU2VyaWFsaXplcjtcblxuICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZSgpO1xufVxuXG4vLyBSZW1vdmUgYWxsIGtleXMgZnJvbSB0aGUgZGF0YXN0b3JlLCBlZmZlY3RpdmVseSBkZXN0cm95aW5nIGFsbCBkYXRhIGluXG4vLyB0aGUgYXBwJ3Mga2V5L3ZhbHVlIHN0b3JlIVxuZnVuY3Rpb24gY2xlYXIkMihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleVByZWZpeCA9IHNlbGYuX2RiSW5mby5rZXlQcmVmaXg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGxvY2FsU3RvcmFnZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG5cbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihrZXlQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gUmV0cmlldmUgYW4gaXRlbSBmcm9tIHRoZSBzdG9yZS4gVW5saWtlIHRoZSBvcmlnaW5hbCBhc3luY19zdG9yYWdlXG4vLyBsaWJyYXJ5IGluIEdhaWEsIHdlIGRvbid0IG1vZGlmeSByZXR1cm4gdmFsdWVzIGF0IGFsbC4gSWYgYSBrZXkncyB2YWx1ZVxuLy8gaXMgYHVuZGVmaW5lZGAsIHdlIHBhc3MgdGhhdCB2YWx1ZSB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5mdW5jdGlvbiBnZXRJdGVtJDIoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIHZhciByZXN1bHQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShkYkluZm8ua2V5UHJlZml4ICsga2V5KTtcblxuICAgICAgICAvLyBJZiBhIHJlc3VsdCB3YXMgZm91bmQsIHBhcnNlIGl0IGZyb20gdGhlIHNlcmlhbGl6ZWRcbiAgICAgICAgLy8gc3RyaW5nIGludG8gYSBKUyBvYmplY3QuIElmIHJlc3VsdCBpc24ndCB0cnV0aHksIHRoZSBrZXlcbiAgICAgICAgLy8gaXMgbGlrZWx5IHVuZGVmaW5lZCBhbmQgd2UnbGwgcGFzcyBpdCBzdHJhaWdodCB0byB0aGVcbiAgICAgICAgLy8gY2FsbGJhY2suXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRiSW5mby5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gSXRlcmF0ZSBvdmVyIGFsbCBpdGVtcyBpbiB0aGUgc3RvcmUuXG5mdW5jdGlvbiBpdGVyYXRlJDIoaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIHZhciBrZXlQcmVmaXggPSBkYkluZm8ua2V5UHJlZml4O1xuICAgICAgICB2YXIga2V5UHJlZml4TGVuZ3RoID0ga2V5UHJlZml4Lmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxvY2FsU3RvcmFnZS5sZW5ndGg7XG5cbiAgICAgICAgLy8gV2UgdXNlIGEgZGVkaWNhdGVkIGl0ZXJhdG9yIGluc3RlYWQgb2YgdGhlIGBpYCB2YXJpYWJsZSBiZWxvd1xuICAgICAgICAvLyBzbyBvdGhlciBrZXlzIHdlIGZldGNoIGluIGxvY2FsU3RvcmFnZSBhcmVuJ3QgY291bnRlZCBpblxuICAgICAgICAvLyB0aGUgYGl0ZXJhdGlvbk51bWJlcmAgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBgaXRlcmF0ZSgpYFxuICAgICAgICAvLyBjYWxsYmFjay5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2VlOiBnaXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvcHVsbC80MzUjZGlzY3Vzc2lvbl9yMzgwNjE1MzBcbiAgICAgICAgdmFyIGl0ZXJhdGlvbk51bWJlciA9IDE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yoa2V5UHJlZml4KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcblxuICAgICAgICAgICAgLy8gSWYgYSByZXN1bHQgd2FzIGZvdW5kLCBwYXJzZSBpdCBmcm9tIHRoZSBzZXJpYWxpemVkXG4gICAgICAgICAgICAvLyBzdHJpbmcgaW50byBhIEpTIG9iamVjdC4gSWYgcmVzdWx0IGlzbid0IHRydXRoeSwgdGhlXG4gICAgICAgICAgICAvLyBrZXkgaXMgbGlrZWx5IHVuZGVmaW5lZCBhbmQgd2UnbGwgcGFzcyBpdCBzdHJhaWdodFxuICAgICAgICAgICAgLy8gdG8gdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gaXRlcmF0b3IodmFsdWUsIGtleS5zdWJzdHJpbmcoa2V5UHJlZml4TGVuZ3RoKSwgaXRlcmF0aW9uTnVtYmVyKyspO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gU2FtZSBhcyBsb2NhbFN0b3JhZ2UncyBrZXkoKSBtZXRob2QsIGV4Y2VwdCB0YWtlcyBhIGNhbGxiYWNrLlxuZnVuY3Rpb24ga2V5JDIobiwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBsb2NhbFN0b3JhZ2Uua2V5KG4pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcHJlZml4IGZyb20gdGhlIGtleSwgaWYgYSBrZXkgaXMgZm91bmQuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoZGJJbmZvLmtleVByZWZpeC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleXMkMihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxvY2FsU3RvcmFnZS5sZW5ndGg7XG4gICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW1LZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICAgICAgaWYgKGl0ZW1LZXkuaW5kZXhPZihkYkluZm8ua2V5UHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChpdGVtS2V5LnN1YnN0cmluZyhkYkluZm8ua2V5UHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBTdXBwbHkgdGhlIG51bWJlciBvZiBrZXlzIGluIHRoZSBkYXRhc3RvcmUgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuZnVuY3Rpb24gbGVuZ3RoJDIoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2UgPSBzZWxmLmtleXMoKS50aGVuKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIHN0b3JlLCBuaWNlIGFuZCBzaW1wbGUuXG5mdW5jdGlvbiByZW1vdmVJdGVtJDIoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGRiSW5mby5rZXlQcmVmaXggKyBrZXkpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gU2V0IGEga2V5J3MgdmFsdWUgYW5kIHJ1biBhbiBvcHRpb25hbCBjYWxsYmFjayBvbmNlIHRoZSB2YWx1ZSBpcyBzZXQuXG4vLyBVbmxpa2UgR2FpYSdzIGltcGxlbWVudGF0aW9uLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSB2YWx1ZSxcbi8vIGluIGNhc2UgeW91IHdhbnQgdG8gb3BlcmF0ZSBvbiB0aGF0IHZhbHVlIG9ubHkgYWZ0ZXIgeW91J3JlIHN1cmUgaXRcbi8vIHNhdmVkLCBvciBzb21ldGhpbmcgbGlrZSB0aGF0LlxuZnVuY3Rpb24gc2V0SXRlbSQyKGtleSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ29udmVydCB1bmRlZmluZWQgdmFsdWVzIHRvIG51bGwuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL3B1bGwvNDJcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmUgdGhlIG9yaWdpbmFsIHZhbHVlIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uc2VyaWFsaXplci5zZXJpYWxpemUodmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZGJJbmZvLmtleVByZWZpeCArIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvcmlnaW5hbFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9jYWxTdG9yYWdlIGNhcGFjaXR5IGV4Y2VlZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTWFrZSB0aGlzIGEgc3BlY2lmaWMgZXJyb3IvZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJyB8fCBlLm5hbWUgPT09ICdOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBkcm9wSW5zdGFuY2UkMihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHZhciBjdXJyZW50Q29uZmlnID0gdGhpcy5jb25maWcoKTtcbiAgICAgICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IGN1cnJlbnRDb25maWcubmFtZTtcbiAgICAgICAgb3B0aW9ucy5zdG9yZU5hbWUgPSBvcHRpb25zLnN0b3JlTmFtZSB8fCBjdXJyZW50Q29uZmlnLnN0b3JlTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2U7XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZWplY3QoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG9wdGlvbnMubmFtZSArICcvJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX2dldEtleVByZWZpeChvcHRpb25zLCBzZWxmLl9kZWZhdWx0Q29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGtleVByZWZpeCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxvY2FsU3RvcmFnZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKGtleVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBsb2NhbFN0b3JhZ2VXcmFwcGVyID0ge1xuICAgIF9kcml2ZXI6ICdsb2NhbFN0b3JhZ2VXcmFwcGVyJyxcbiAgICBfaW5pdFN0b3JhZ2U6IF9pbml0U3RvcmFnZSQyLFxuICAgIF9zdXBwb3J0OiBpc0xvY2FsU3RvcmFnZVZhbGlkKCksXG4gICAgaXRlcmF0ZTogaXRlcmF0ZSQyLFxuICAgIGdldEl0ZW06IGdldEl0ZW0kMixcbiAgICBzZXRJdGVtOiBzZXRJdGVtJDIsXG4gICAgcmVtb3ZlSXRlbTogcmVtb3ZlSXRlbSQyLFxuICAgIGNsZWFyOiBjbGVhciQyLFxuICAgIGxlbmd0aDogbGVuZ3RoJDIsXG4gICAga2V5OiBrZXkkMixcbiAgICBrZXlzOiBrZXlzJDIsXG4gICAgZHJvcEluc3RhbmNlOiBkcm9wSW5zdGFuY2UkMlxufTtcblxudmFyIHNhbWVWYWx1ZSA9IGZ1bmN0aW9uIHNhbWVWYWx1ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHggPT09IHkgfHwgdHlwZW9mIHggPT09ICdudW1iZXInICYmIHR5cGVvZiB5ID09PSAnbnVtYmVyJyAmJiBpc05hTih4KSAmJiBpc05hTih5KTtcbn07XG5cbnZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKGFycmF5LCBzZWFyY2hFbGVtZW50KSB7XG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHNhbWVWYWx1ZShhcnJheVtpXSwgc2VhcmNoRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIERyaXZlcnMgYXJlIHN0b3JlZCBoZXJlIHdoZW4gYGRlZmluZURyaXZlcigpYCBpcyBjYWxsZWQuXG4vLyBUaGV5IGFyZSBzaGFyZWQgYWNyb3NzIGFsbCBpbnN0YW5jZXMgb2YgbG9jYWxGb3JhZ2UuXG52YXIgRGVmaW5lZERyaXZlcnMgPSB7fTtcblxudmFyIERyaXZlclN1cHBvcnQgPSB7fTtcblxudmFyIERlZmF1bHREcml2ZXJzID0ge1xuICAgIElOREVYRUREQjogYXN5bmNTdG9yYWdlLFxuICAgIFdFQlNRTDogd2ViU1FMU3RvcmFnZSxcbiAgICBMT0NBTFNUT1JBR0U6IGxvY2FsU3RvcmFnZVdyYXBwZXJcbn07XG5cbnZhciBEZWZhdWx0RHJpdmVyT3JkZXIgPSBbRGVmYXVsdERyaXZlcnMuSU5ERVhFRERCLl9kcml2ZXIsIERlZmF1bHREcml2ZXJzLldFQlNRTC5fZHJpdmVyLCBEZWZhdWx0RHJpdmVycy5MT0NBTFNUT1JBR0UuX2RyaXZlcl07XG5cbnZhciBPcHRpb25hbERyaXZlck1ldGhvZHMgPSBbJ2Ryb3BJbnN0YW5jZSddO1xuXG52YXIgTGlicmFyeU1ldGhvZHMgPSBbJ2NsZWFyJywgJ2dldEl0ZW0nLCAnaXRlcmF0ZScsICdrZXknLCAna2V5cycsICdsZW5ndGgnLCAncmVtb3ZlSXRlbScsICdzZXRJdGVtJ10uY29uY2F0KE9wdGlvbmFsRHJpdmVyTWV0aG9kcyk7XG5cbnZhciBEZWZhdWx0Q29uZmlnID0ge1xuICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICBkcml2ZXI6IERlZmF1bHREcml2ZXJPcmRlci5zbGljZSgpLFxuICAgIG5hbWU6ICdsb2NhbGZvcmFnZScsXG4gICAgLy8gRGVmYXVsdCBEQiBzaXplIGlzIF9KVVNUIFVOREVSXyA1TUIsIGFzIGl0J3MgdGhlIGhpZ2hlc3Qgc2l6ZVxuICAgIC8vIHdlIGNhbiB1c2Ugd2l0aG91dCBhIHByb21wdC5cbiAgICBzaXplOiA0OTgwNzM2LFxuICAgIHN0b3JlTmFtZTogJ2tleXZhbHVlcGFpcnMnLFxuICAgIHZlcnNpb246IDEuMFxufTtcblxuZnVuY3Rpb24gY2FsbFdoZW5SZWFkeShsb2NhbEZvcmFnZUluc3RhbmNlLCBsaWJyYXJ5TWV0aG9kKSB7XG4gICAgbG9jYWxGb3JhZ2VJbnN0YW5jZVtsaWJyYXJ5TWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbG9jYWxGb3JhZ2VJbnN0YW5jZS5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsRm9yYWdlSW5zdGFuY2VbbGlicmFyeU1ldGhvZF0uYXBwbHkobG9jYWxGb3JhZ2VJbnN0YW5jZSwgX2FyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfa2V5IGluIGFyZykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcuaGFzT3duUHJvcGVydHkoX2tleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJnW19rZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdW19rZXldID0gYXJnW19rZXldLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF1bX2tleV0gPSBhcmdbX2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xufVxuXG52YXIgTG9jYWxGb3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9jYWxGb3JhZ2Uob3B0aW9ucykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9jYWxGb3JhZ2UpO1xuXG4gICAgICAgIGZvciAodmFyIGRyaXZlclR5cGVLZXkgaW4gRGVmYXVsdERyaXZlcnMpIHtcbiAgICAgICAgICAgIGlmIChEZWZhdWx0RHJpdmVycy5oYXNPd25Qcm9wZXJ0eShkcml2ZXJUeXBlS2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBkcml2ZXIgPSBEZWZhdWx0RHJpdmVyc1tkcml2ZXJUeXBlS2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IGRyaXZlci5fZHJpdmVyO1xuICAgICAgICAgICAgICAgIHRoaXNbZHJpdmVyVHlwZUtleV0gPSBkcml2ZXJOYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHdhaXQgZm9yIHRoZSBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCBkcml2ZXJzIGNhbiBiZSBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGEgYmxvY2tpbmcgbWFubmVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lRHJpdmVyKGRyaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVmYXVsdENvbmZpZyA9IGV4dGVuZCh7fSwgRGVmYXVsdENvbmZpZyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGV4dGVuZCh7fSwgdGhpcy5fZGVmYXVsdENvbmZpZywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2RyaXZlclNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luaXREcml2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kYkluZm8gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSgpO1xuICAgICAgICB0aGlzLnNldERyaXZlcih0aGlzLl9jb25maWcuZHJpdmVyKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYW55IGNvbmZpZyB2YWx1ZXMgZm9yIGxvY2FsRm9yYWdlOyBjYW4gYmUgY2FsbGVkIGFueXRpbWUgYmVmb3JlXG4gICAgLy8gdGhlIGZpcnN0IEFQSSBjYWxsIChlLmcuIGBnZXRJdGVtYCwgYHNldEl0ZW1gKS5cbiAgICAvLyBXZSBsb29wIHRocm91Z2ggb3B0aW9ucyBzbyB3ZSBkb24ndCBvdmVyd3JpdGUgZXhpc3RpbmcgY29uZmlnXG4gICAgLy8gdmFsdWVzLlxuXG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuY29uZmlnID0gZnVuY3Rpb24gY29uZmlnKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIG9wdGlvbnMgYXJndW1lbnQgaXMgYW4gb2JqZWN0LCB3ZSB1c2UgaXQgdG8gc2V0IHZhbHVlcy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSByZXR1cm4gZWl0aGVyIGEgc3BlY2lmaWVkIGNvbmZpZyB2YWx1ZSBvciBhbGxcbiAgICAgICAgLy8gY29uZmlnIHZhbHVlcy5cbiAgICAgICAgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0aW9ucykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gSWYgbG9jYWxmb3JhZ2UgaXMgcmVhZHkgYW5kIGZ1bGx5IGluaXRpYWxpemVkLCB3ZSBjYW4ndCBzZXRcbiAgICAgICAgICAgIC8vIGFueSBuZXcgY29uZmlndXJhdGlvbiB2YWx1ZXMuIEluc3RlYWQsIHdlIHJldHVybiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJDYW4ndCBjYWxsIGNvbmZpZygpIGFmdGVyIGxvY2FsZm9yYWdlIFwiICsgJ2hhcyBiZWVuIHVzZWQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAnc3RvcmVOYW1lJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2ldID0gb3B0aW9uc1tpXS5yZXBsYWNlKC9cXFcvZywgJ18nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gJ3ZlcnNpb24nICYmIHR5cGVvZiBvcHRpb25zW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdEYXRhYmFzZSB2ZXJzaW9uIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fY29uZmlnW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWZ0ZXIgYWxsIGNvbmZpZyBvcHRpb25zIGFyZSBzZXQgYW5kXG4gICAgICAgICAgICAvLyB0aGUgZHJpdmVyIG9wdGlvbiBpcyB1c2VkLCB0cnkgc2V0dGluZyBpdFxuICAgICAgICAgICAgaWYgKCdkcml2ZXInIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5kcml2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREcml2ZXIodGhpcy5fY29uZmlnLmRyaXZlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZ1tvcHRpb25zXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVXNlZCB0byBkZWZpbmUgYSBjdXN0b20gZHJpdmVyLCBzaGFyZWQgYWNyb3NzIGFsbCBpbnN0YW5jZXMgb2ZcbiAgICAvLyBsb2NhbEZvcmFnZS5cblxuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmRlZmluZURyaXZlciA9IGZ1bmN0aW9uIGRlZmluZURyaXZlcihkcml2ZXJPYmplY3QsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gZHJpdmVyT2JqZWN0Ll9kcml2ZXI7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsaWFuY2VFcnJvciA9IG5ldyBFcnJvcignQ3VzdG9tIGRyaXZlciBub3QgY29tcGxpYW50OyBzZWUgJyArICdodHRwczovL21vemlsbGEuZ2l0aHViLmlvL2xvY2FsRm9yYWdlLyNkZWZpbmVkcml2ZXInKTtcblxuICAgICAgICAgICAgICAgIC8vIEEgZHJpdmVyIG5hbWUgc2hvdWxkIGJlIGRlZmluZWQgYW5kIG5vdCBvdmVybGFwIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gbGlicmFyeS1kZWZpbmVkLCBkZWZhdWx0IGRyaXZlcnMuXG4gICAgICAgICAgICAgICAgaWYgKCFkcml2ZXJPYmplY3QuX2RyaXZlcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoY29tcGxpYW5jZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkcml2ZXJNZXRob2RzID0gTGlicmFyeU1ldGhvZHMuY29uY2F0KCdfaW5pdFN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZHJpdmVyTWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTWV0aG9kTmFtZSA9IGRyaXZlck1ldGhvZHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgcHJvcGVydHkgaXMgdGhlcmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBhIG1ldGhvZCBldmVuIHdoZW4gb3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUmVxdWlyZWQgPSAhaW5jbHVkZXMoT3B0aW9uYWxEcml2ZXJNZXRob2RzLCBkcml2ZXJNZXRob2ROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpc1JlcXVpcmVkIHx8IGRyaXZlck9iamVjdFtkcml2ZXJNZXRob2ROYW1lXSkgJiYgdHlwZW9mIGRyaXZlck9iamVjdFtkcml2ZXJNZXRob2ROYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGNvbXBsaWFuY2VFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29uZmlndXJlTWlzc2luZ01ldGhvZHMgPSBmdW5jdGlvbiBjb25maWd1cmVNaXNzaW5nTWV0aG9kcygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZE5vdEltcGxlbWVudGVkRmFjdG9yeSA9IGZ1bmN0aW9uIG1ldGhvZE5vdEltcGxlbWVudGVkRmFjdG9yeShtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTWV0aG9kICcgKyBtZXRob2ROYW1lICsgJyBpcyBub3QgaW1wbGVtZW50ZWQgYnkgdGhlIGN1cnJlbnQgZHJpdmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2xlbiA9IE9wdGlvbmFsRHJpdmVyTWV0aG9kcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbmFsRHJpdmVyTWV0aG9kID0gT3B0aW9uYWxEcml2ZXJNZXRob2RzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJpdmVyT2JqZWN0W29wdGlvbmFsRHJpdmVyTWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyaXZlck9iamVjdFtvcHRpb25hbERyaXZlck1ldGhvZF0gPSBtZXRob2ROb3RJbXBsZW1lbnRlZEZhY3Rvcnkob3B0aW9uYWxEcml2ZXJNZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZU1pc3NpbmdNZXRob2RzKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2V0RHJpdmVyU3VwcG9ydCA9IGZ1bmN0aW9uIHNldERyaXZlclN1cHBvcnQoc3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnUmVkZWZpbmluZyBMb2NhbEZvcmFnZSBkcml2ZXI6ICcgKyBkcml2ZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSA9IGRyaXZlck9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgRHJpdmVyU3VwcG9ydFtkcml2ZXJOYW1lXSA9IHN1cHBvcnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHVzZSBhIHRoZW4sIHNvIHRoYXQgd2UgY2FuIGRlZmluZVxuICAgICAgICAgICAgICAgICAgICAvLyBkcml2ZXJzIHRoYXQgaGF2ZSBzaW1wbGUgX3N1cHBvcnQgbWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBhIGJsb2NraW5nIG1hbm5lclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICgnX3N1cHBvcnQnIGluIGRyaXZlck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJpdmVyT2JqZWN0Ll9zdXBwb3J0ICYmIHR5cGVvZiBkcml2ZXJPYmplY3QuX3N1cHBvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyaXZlck9iamVjdC5fc3VwcG9ydCgpLnRoZW4oc2V0RHJpdmVyU3VwcG9ydCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldERyaXZlclN1cHBvcnQoISFkcml2ZXJPYmplY3QuX3N1cHBvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RHJpdmVyU3VwcG9ydCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKHByb21pc2UsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5kcml2ZXIgPSBmdW5jdGlvbiBkcml2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcml2ZXIgfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmdldERyaXZlciA9IGZ1bmN0aW9uIGdldERyaXZlcihkcml2ZXJOYW1lLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgZ2V0RHJpdmVyUHJvbWlzZSA9IERlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdID8gUHJvbWlzZSQxLnJlc29sdmUoRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0pIDogUHJvbWlzZSQxLnJlamVjdChuZXcgRXJyb3IoJ0RyaXZlciBub3QgZm91bmQuJykpO1xuXG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3MoZ2V0RHJpdmVyUHJvbWlzZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gZ2V0RHJpdmVyUHJvbWlzZTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmdldFNlcmlhbGl6ZXIgPSBmdW5jdGlvbiBnZXRTZXJpYWxpemVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVyUHJvbWlzZSA9IFByb21pc2UkMS5yZXNvbHZlKGxvY2FsZm9yYWdlU2VyaWFsaXplcik7XG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3Moc2VyaWFsaXplclByb21pc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXJQcm9taXNlO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeShjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSBzZWxmLl9kcml2ZXJTZXQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fcmVhZHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9yZWFkeSA9IHNlbGYuX2luaXREcml2ZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlYWR5O1xuICAgICAgICB9KTtcblxuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKHByb21pc2UsIGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuc2V0RHJpdmVyID0gZnVuY3Rpb24gc2V0RHJpdmVyKGRyaXZlcnMsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoIWlzQXJyYXkoZHJpdmVycykpIHtcbiAgICAgICAgICAgIGRyaXZlcnMgPSBbZHJpdmVyc107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VwcG9ydGVkRHJpdmVycyA9IHRoaXMuX2dldFN1cHBvcnRlZERyaXZlcnMoZHJpdmVycyk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0RHJpdmVyVG9Db25maWcoKSB7XG4gICAgICAgICAgICBzZWxmLl9jb25maWcuZHJpdmVyID0gc2VsZi5kcml2ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4dGVuZFNlbGZXaXRoRHJpdmVyKGRyaXZlcikge1xuICAgICAgICAgICAgc2VsZi5fZXh0ZW5kKGRyaXZlcik7XG4gICAgICAgICAgICBzZXREcml2ZXJUb0NvbmZpZygpO1xuXG4gICAgICAgICAgICBzZWxmLl9yZWFkeSA9IHNlbGYuX2luaXRTdG9yYWdlKHNlbGYuX2NvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcmVhZHk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0RHJpdmVyKHN1cHBvcnRlZERyaXZlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnREcml2ZXJJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkcml2ZXJQcm9taXNlTG9vcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnREcml2ZXJJbmRleCA8IHN1cHBvcnRlZERyaXZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IHN1cHBvcnRlZERyaXZlcnNbY3VycmVudERyaXZlckluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREcml2ZXJJbmRleCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9kYkluZm8gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVhZHkgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXREcml2ZXIoZHJpdmVyTmFtZSkudGhlbihleHRlbmRTZWxmV2l0aERyaXZlcilbXCJjYXRjaFwiXShkcml2ZXJQcm9taXNlTG9vcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXREcml2ZXJUb0NvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIGF2YWlsYWJsZSBzdG9yYWdlIG1ldGhvZCBmb3VuZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZHJpdmVyU2V0ID0gUHJvbWlzZSQxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9kcml2ZXJTZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyaXZlclByb21pc2VMb29wKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgYSBkcml2ZXIgaW5pdGlhbGl6YXRpb24gaW4gcHJvZ3Jlc3NcbiAgICAgICAgLy8gc28gd2FpdCBmb3IgaXQgdG8gZmluaXNoIGluIG9yZGVyIHRvIGF2b2lkIGEgcG9zc2libGVcbiAgICAgICAgLy8gcmFjZSBjb25kaXRpb24gdG8gc2V0IF9kYkluZm9cbiAgICAgICAgdmFyIG9sZERyaXZlclNldERvbmUgPSB0aGlzLl9kcml2ZXJTZXQgIT09IG51bGwgPyB0aGlzLl9kcml2ZXJTZXRbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZSQxLnJlc29sdmUoKTtcbiAgICAgICAgfSkgOiBQcm9taXNlJDEucmVzb2x2ZSgpO1xuXG4gICAgICAgIHRoaXMuX2RyaXZlclNldCA9IG9sZERyaXZlclNldERvbmUudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IHN1cHBvcnRlZERyaXZlcnNbMF07XG4gICAgICAgICAgICBzZWxmLl9kYkluZm8gPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5fcmVhZHkgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXREcml2ZXIoZHJpdmVyTmFtZSkudGhlbihmdW5jdGlvbiAoZHJpdmVyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZHJpdmVyID0gZHJpdmVyLl9kcml2ZXI7XG4gICAgICAgICAgICAgICAgc2V0RHJpdmVyVG9Db25maWcoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0RHJpdmVyID0gaW5pdERyaXZlcihzdXBwb3J0ZWREcml2ZXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldERyaXZlclRvQ29uZmlnKCk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIGF2YWlsYWJsZSBzdG9yYWdlIG1ldGhvZCBmb3VuZC4nKTtcbiAgICAgICAgICAgIHNlbGYuX2RyaXZlclNldCA9IFByb21pc2UkMS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2RyaXZlclNldDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyh0aGlzLl9kcml2ZXJTZXQsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyaXZlclNldDtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gc3VwcG9ydHMoZHJpdmVyTmFtZSkge1xuICAgICAgICByZXR1cm4gISFEcml2ZXJTdXBwb3J0W2RyaXZlck5hbWVdO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuX2V4dGVuZCA9IGZ1bmN0aW9uIF9leHRlbmQobGlicmFyeU1ldGhvZHNBbmRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLCBsaWJyYXJ5TWV0aG9kc0FuZFByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuX2dldFN1cHBvcnRlZERyaXZlcnMgPSBmdW5jdGlvbiBfZ2V0U3VwcG9ydGVkRHJpdmVycyhkcml2ZXJzKSB7XG4gICAgICAgIHZhciBzdXBwb3J0ZWREcml2ZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkcml2ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IGRyaXZlcnNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0cyhkcml2ZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRlZERyaXZlcnMucHVzaChkcml2ZXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkRHJpdmVycztcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkgPSBmdW5jdGlvbiBfd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5KCkge1xuICAgICAgICAvLyBBZGQgYSBzdHViIGZvciBlYWNoIGRyaXZlciBBUEkgbWV0aG9kIHRoYXQgZGVsYXlzIHRoZSBjYWxsIHRvIHRoZVxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGRyaXZlciBtZXRob2QgdW50aWwgbG9jYWxGb3JhZ2UgaXMgcmVhZHkuIFRoZXNlIHN0dWJzXG4gICAgICAgIC8vIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGRyaXZlciBtZXRob2RzIGFzIHNvb24gYXMgdGhlIGRyaXZlciBpc1xuICAgICAgICAvLyBsb2FkZWQsIHNvIHRoZXJlIGlzIG5vIHBlcmZvcm1hbmNlIGltcGFjdC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IExpYnJhcnlNZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjYWxsV2hlblJlYWR5KHRoaXMsIExpYnJhcnlNZXRob2RzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9jYWxGb3JhZ2Uob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBMb2NhbEZvcmFnZTtcbn0oKTtcblxuLy8gVGhlIGFjdHVhbCBsb2NhbEZvcmFnZSBvYmplY3QgdGhhdCB3ZSBleHBvc2UgYXMgYSBtb2R1bGUgb3IgdmlhIGFcbi8vIGdsb2JhbC4gSXQncyBleHRlbmRlZCBieSBwdWxsaW5nIGluIG9uZSBvZiBvdXIgb3RoZXIgbGlicmFyaWVzLlxuXG5cbnZhciBsb2NhbGZvcmFnZV9qcyA9IG5ldyBMb2NhbEZvcmFnZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvY2FsZm9yYWdlX2pzO1xuXG59LHtcIjNcIjozfV19LHt9LFs0XSkoNClcbn0pO1xuIl0sIm5hbWVzIjpbImYiLCJleHBvcnRzIiwiX3R5cGVvZjIiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImxvY2FsZm9yYWdlIiwiZSIsInQiLCJuIiwiciIsInMiLCJvIiwidSIsImEiLCJyZXF1aXJlIiwiaSIsIkVycm9yIiwiY29kZSIsImwiLCJjYWxsIiwibGVuZ3RoIiwiX2RlcmVxXyIsIk11dGF0aW9uIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJzY2hlZHVsZURyYWluIiwiY2FsbGVkIiwib2JzZXJ2ZXIiLCJuZXh0VGljayIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJkYXRhIiwic2V0SW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwiY3JlYXRlRWxlbWVudCIsInNjcmlwdEVsIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZG9jdW1lbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJzZXRUaW1lb3V0IiwiZHJhaW5pbmciLCJxdWV1ZSIsIm9sZFF1ZXVlIiwibGVuIiwiaW1tZWRpYXRlIiwidGFzayIsInB1c2giLCJJTlRFUk5BTCIsImhhbmRsZXJzIiwiUkVKRUNURUQiLCJGVUxGSUxMRUQiLCJQRU5ESU5HIiwiUHJvbWlzZSIsInJlc29sdmVyIiwiVHlwZUVycm9yIiwic3RhdGUiLCJvdXRjb21lIiwic2FmZWx5UmVzb2x2ZVRoZW5hYmxlIiwicHJvdG90eXBlIiwib25SZWplY3RlZCIsInRoZW4iLCJvbkZ1bGZpbGxlZCIsInByb21pc2UiLCJjb25zdHJ1Y3RvciIsInVud3JhcCIsIlF1ZXVlSXRlbSIsImNhbGxGdWxmaWxsZWQiLCJvdGhlckNhbGxGdWxmaWxsZWQiLCJjYWxsUmVqZWN0ZWQiLCJvdGhlckNhbGxSZWplY3RlZCIsInZhbHVlIiwicmVzb2x2ZSIsInJlamVjdCIsImZ1bmMiLCJyZXR1cm5WYWx1ZSIsInJlc3VsdCIsInRyeUNhdGNoIiwiZ2V0VGhlbiIsInN0YXR1cyIsInRoZW5hYmxlIiwiZXJyb3IiLCJvYmoiLCJhcHB5VGhlbiIsImFwcGx5IiwiYXJndW1lbnRzIiwib25FcnJvciIsIm9uU3VjY2VzcyIsInRyeVRvVW53cmFwIiwib3V0IiwicmVhc29uIiwiYWxsIiwiaXRlcmFibGUiLCJPYmplY3QiLCJ0b1N0cmluZyIsInZhbHVlcyIsIkFycmF5IiwicmVzb2x2ZWQiLCJhbGxSZXNvbHZlciIsInJlc29sdmVGcm9tQWxsIiwib3V0VmFsdWUiLCJyYWNlIiwicmVzcG9uc2UiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiZ2V0SURCIiwiaW5kZXhlZERCIiwid2Via2l0SW5kZXhlZERCIiwibW96SW5kZXhlZERCIiwiT0luZGV4ZWREQiIsIm1zSW5kZXhlZERCIiwiaWRiIiwiaXNJbmRleGVkREJWYWxpZCIsIm9wZW4iLCJpc1NhZmFyaSIsIm9wZW5EYXRhYmFzZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJwbGF0Zm9ybSIsImhhc0ZldGNoIiwiZmV0Y2giLCJpbmRleE9mIiwiSURCS2V5UmFuZ2UiLCJjcmVhdGVCbG9iIiwicGFydHMiLCJwcm9wZXJ0aWVzIiwiQmxvYiIsIm5hbWUiLCJCdWlsZGVyIiwiQmxvYkJ1aWxkZXIiLCJNU0Jsb2JCdWlsZGVyIiwiTW96QmxvYkJ1aWxkZXIiLCJXZWJLaXRCbG9iQnVpbGRlciIsImJ1aWxkZXIiLCJhcHBlbmQiLCJnZXRCbG9iIiwidHlwZSIsIlByb21pc2UkMSIsImV4ZWN1dGVDYWxsYmFjayIsImNhbGxiYWNrIiwiZXhlY3V0ZVR3b0NhbGxiYWNrcyIsImVycm9yQ2FsbGJhY2siLCJub3JtYWxpemVLZXkiLCJrZXkiLCJjb25zb2xlIiwid2FybiIsIlN0cmluZyIsImdldENhbGxiYWNrIiwiREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSIsInN1cHBvcnRzQmxvYnMiLCJkYkNvbnRleHRzIiwiUkVBRF9PTkxZIiwiUkVBRF9XUklURSIsIl9iaW5TdHJpbmdUb0FycmF5QnVmZmVyIiwiYmluIiwiYnVmIiwiQXJyYXlCdWZmZXIiLCJhcnIiLCJVaW50OEFycmF5IiwiY2hhckNvZGVBdCIsIl9jaGVja0Jsb2JTdXBwb3J0V2l0aG91dENhY2hpbmciLCJ0eG4iLCJ0cmFuc2FjdGlvbiIsImJsb2IiLCJvYmplY3RTdG9yZSIsInB1dCIsIm9uYWJvcnQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIm9uY29tcGxldGUiLCJtYXRjaGVkQ2hyb21lIiwibWF0Y2giLCJtYXRjaGVkRWRnZSIsInBhcnNlSW50IiwiX2NoZWNrQmxvYlN1cHBvcnQiLCJfZGVmZXJSZWFkaW5lc3MiLCJkYkluZm8iLCJkYkNvbnRleHQiLCJkZWZlcnJlZE9wZXJhdGlvbiIsImRlZmVycmVkT3BlcmF0aW9ucyIsImRiUmVhZHkiLCJfYWR2YW5jZVJlYWRpbmVzcyIsInBvcCIsIl9yZWplY3RSZWFkaW5lc3MiLCJlcnIiLCJfZ2V0Q29ubmVjdGlvbiIsInVwZ3JhZGVOZWVkZWQiLCJjcmVhdGVEYkNvbnRleHQiLCJkYiIsImNsb3NlIiwiZGJBcmdzIiwidmVyc2lvbiIsIm9wZW5yZXEiLCJvbnVwZ3JhZGVuZWVkZWQiLCJjcmVhdGVPYmplY3RTdG9yZSIsInN0b3JlTmFtZSIsIm9sZFZlcnNpb24iLCJleCIsIm5ld1ZlcnNpb24iLCJvbmVycm9yIiwib25zdWNjZXNzIiwib252ZXJzaW9uY2hhbmdlIiwidGFyZ2V0IiwiX2dldE9yaWdpbmFsQ29ubmVjdGlvbiIsIl9nZXRVcGdyYWRlZENvbm5lY3Rpb24iLCJfaXNVcGdyYWRlTmVlZGVkIiwiZGVmYXVsdFZlcnNpb24iLCJpc05ld1N0b3JlIiwib2JqZWN0U3RvcmVOYW1lcyIsImNvbnRhaW5zIiwiaXNEb3duZ3JhZGUiLCJpc1VwZ3JhZGUiLCJpbmNWZXJzaW9uIiwiX2VuY29kZUJsb2IiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkZW5kIiwiYmFzZTY0IiwiYnRvYSIsIl9fbG9jYWxfZm9yYWdlX2VuY29kZWRfYmxvYiIsInJlYWRBc0JpbmFyeVN0cmluZyIsIl9kZWNvZGVCbG9iIiwiZW5jb2RlZEJsb2IiLCJhcnJheUJ1ZmYiLCJhdG9iIiwiX2lzRW5jb2RlZEJsb2IiLCJfZnVsbHlSZWFkeSIsIl9pbml0UmVhZHkiLCJfZGJJbmZvIiwiX3RyeVJlY29ubmVjdCIsImZvcmFnZXMiLCJmb3JhZ2UiLCJjcmVhdGVUcmFuc2FjdGlvbiIsIm1vZGUiLCJyZXRyaWVzIiwidW5kZWZpbmVkIiwidHgiLCJfaW5pdFN0b3JhZ2UiLCJvcHRpb25zIiwicmVhZHkiLCJpbml0UHJvbWlzZXMiLCJpZ25vcmVFcnJvcnMiLCJqIiwic2xpY2UiLCJfZGVmYXVsdENvbmZpZyIsImsiLCJnZXRJdGVtIiwic3RvcmUiLCJyZXEiLCJnZXQiLCJpdGVyYXRlIiwib3BlbkN1cnNvciIsIml0ZXJhdGlvbk51bWJlciIsImN1cnNvciIsInNldEl0ZW0iLCJibG9iU3VwcG9ydCIsInJlbW92ZUl0ZW0iLCJjbGVhciIsImNvdW50IiwiYWR2YW5jZWQiLCJvcGVuS2V5Q3Vyc29yIiwiYWR2YW5jZSIsImtleXMiLCJkcm9wSW5zdGFuY2UiLCJjdXJyZW50Q29uZmlnIiwiY29uZmlnIiwiaXNDdXJyZW50RGIiLCJkYlByb21pc2UiLCJkcm9wREJQcm9taXNlIiwiZGVsZXRlRGF0YWJhc2UiLCJvbmJsb2NrZWQiLCJfZm9yYWdlIiwiZHJvcE9iamVjdFByb21pc2UiLCJkZWxldGVPYmplY3RTdG9yZSIsIl9mb3JhZ2UyIiwiYXN5bmNTdG9yYWdlIiwiX2RyaXZlciIsIl9zdXBwb3J0IiwiaXNXZWJTUUxWYWxpZCIsIkJBU0VfQ0hBUlMiLCJCTE9CX1RZUEVfUFJFRklYIiwiQkxPQl9UWVBFX1BSRUZJWF9SRUdFWCIsIlNFUklBTElaRURfTUFSS0VSIiwiU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIIiwiVFlQRV9BUlJBWUJVRkZFUiIsIlRZUEVfQkxPQiIsIlRZUEVfSU5UOEFSUkFZIiwiVFlQRV9VSU5UOEFSUkFZIiwiVFlQRV9VSU5UOENMQU1QRURBUlJBWSIsIlRZUEVfSU5UMTZBUlJBWSIsIlRZUEVfSU5UMzJBUlJBWSIsIlRZUEVfVUlOVDE2QVJSQVkiLCJUWVBFX1VJTlQzMkFSUkFZIiwiVFlQRV9GTE9BVDMyQVJSQVkiLCJUWVBFX0ZMT0FUNjRBUlJBWSIsIlRZUEVfU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIIiwidG9TdHJpbmckMSIsInN0cmluZ1RvQnVmZmVyIiwic2VyaWFsaXplZFN0cmluZyIsImJ1ZmZlckxlbmd0aCIsInAiLCJlbmNvZGVkMSIsImVuY29kZWQyIiwiZW5jb2RlZDMiLCJlbmNvZGVkNCIsImJ1ZmZlciIsImJ5dGVzIiwiYnVmZmVyVG9TdHJpbmciLCJiYXNlNjRTdHJpbmciLCJzdWJzdHJpbmciLCJzZXJpYWxpemUiLCJ2YWx1ZVR5cGUiLCJtYXJrZXIiLCJmaWxlUmVhZGVyIiwib25sb2FkIiwic3RyIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzZXJpYWxpemUiLCJwYXJzZSIsImJsb2JUeXBlIiwibWF0Y2hlciIsIkludDhBcnJheSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwibG9jYWxmb3JhZ2VTZXJpYWxpemVyIiwiY3JlYXRlRGJUYWJsZSIsImV4ZWN1dGVTcWwiLCJfaW5pdFN0b3JhZ2UkMSIsImRiSW5mb1Byb21pc2UiLCJkZXNjcmlwdGlvbiIsInNpemUiLCJzZXJpYWxpemVyIiwidHJ5RXhlY3V0ZVNxbCIsInNxbFN0YXRlbWVudCIsImFyZ3MiLCJTWU5UQVhfRVJSIiwicmVzdWx0cyIsInJvd3MiLCJnZXRJdGVtJDEiLCJpdGVtIiwiaXRlcmF0ZSQxIiwiX3NldEl0ZW0iLCJyZXRyaWVzTGVmdCIsIm9yaWdpbmFsVmFsdWUiLCJzcWxFcnJvciIsIlFVT1RBX0VSUiIsInNldEl0ZW0kMSIsInJlbW92ZUl0ZW0kMSIsImNsZWFyJDEiLCJsZW5ndGgkMSIsImMiLCJrZXkkMSIsImtleXMkMSIsImdldEFsbFN0b3JlTmFtZXMiLCJzdG9yZU5hbWVzIiwiZHJvcEluc3RhbmNlJDEiLCJvcGVyYXRpb25JbmZvIiwiZHJvcFRhYmxlIiwib3BlcmF0aW9ucyIsIndlYlNRTFN0b3JhZ2UiLCJpc0xvY2FsU3RvcmFnZVZhbGlkIiwibG9jYWxTdG9yYWdlIiwiX2dldEtleVByZWZpeCIsImRlZmF1bHRDb25maWciLCJrZXlQcmVmaXgiLCJjaGVja0lmTG9jYWxTdG9yYWdlVGhyb3dzIiwibG9jYWxTdG9yYWdlVGVzdEtleSIsIl9pc0xvY2FsU3RvcmFnZVVzYWJsZSIsIl9pbml0U3RvcmFnZSQyIiwiY2xlYXIkMiIsImdldEl0ZW0kMiIsIml0ZXJhdGUkMiIsImtleVByZWZpeExlbmd0aCIsImtleSQyIiwia2V5cyQyIiwiaXRlbUtleSIsImxlbmd0aCQyIiwicmVtb3ZlSXRlbSQyIiwic2V0SXRlbSQyIiwiZHJvcEluc3RhbmNlJDIiLCJsb2NhbFN0b3JhZ2VXcmFwcGVyIiwic2FtZVZhbHVlIiwieCIsInkiLCJpc05hTiIsImluY2x1ZGVzIiwiYXJyYXkiLCJzZWFyY2hFbGVtZW50IiwiaXNBcnJheSIsImFyZyIsIkRlZmluZWREcml2ZXJzIiwiRHJpdmVyU3VwcG9ydCIsIkRlZmF1bHREcml2ZXJzIiwiSU5ERVhFRERCIiwiV0VCU1FMIiwiTE9DQUxTVE9SQUdFIiwiRGVmYXVsdERyaXZlck9yZGVyIiwiT3B0aW9uYWxEcml2ZXJNZXRob2RzIiwiTGlicmFyeU1ldGhvZHMiLCJjb25jYXQiLCJEZWZhdWx0Q29uZmlnIiwiZHJpdmVyIiwiY2FsbFdoZW5SZWFkeSIsImxvY2FsRm9yYWdlSW5zdGFuY2UiLCJsaWJyYXJ5TWV0aG9kIiwiX2FyZ3MiLCJleHRlbmQiLCJfa2V5IiwiaGFzT3duUHJvcGVydHkiLCJMb2NhbEZvcmFnZSIsImRyaXZlclR5cGVLZXkiLCJkcml2ZXJOYW1lIiwiZGVmaW5lRHJpdmVyIiwiX2NvbmZpZyIsIl9kcml2ZXJTZXQiLCJfaW5pdERyaXZlciIsIl9yZWFkeSIsIl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkiLCJzZXREcml2ZXIiLCJyZXBsYWNlIiwiZHJpdmVyT2JqZWN0IiwiY29tcGxpYW5jZUVycm9yIiwiZHJpdmVyTWV0aG9kcyIsImRyaXZlck1ldGhvZE5hbWUiLCJpc1JlcXVpcmVkIiwiY29uZmlndXJlTWlzc2luZ01ldGhvZHMiLCJtZXRob2ROb3RJbXBsZW1lbnRlZEZhY3RvcnkiLCJtZXRob2ROYW1lIiwiX2kiLCJfbGVuIiwib3B0aW9uYWxEcml2ZXJNZXRob2QiLCJzZXREcml2ZXJTdXBwb3J0Iiwic3VwcG9ydCIsImluZm8iLCJnZXREcml2ZXIiLCJnZXREcml2ZXJQcm9taXNlIiwiZ2V0U2VyaWFsaXplciIsInNlcmlhbGl6ZXJQcm9taXNlIiwiZHJpdmVycyIsInN1cHBvcnRlZERyaXZlcnMiLCJfZ2V0U3VwcG9ydGVkRHJpdmVycyIsInNldERyaXZlclRvQ29uZmlnIiwiZXh0ZW5kU2VsZldpdGhEcml2ZXIiLCJfZXh0ZW5kIiwiaW5pdERyaXZlciIsImN1cnJlbnREcml2ZXJJbmRleCIsImRyaXZlclByb21pc2VMb29wIiwib2xkRHJpdmVyU2V0RG9uZSIsInN1cHBvcnRzIiwibGlicmFyeU1ldGhvZHNBbmRQcm9wZXJ0aWVzIiwiY3JlYXRlSW5zdGFuY2UiLCJsb2NhbGZvcmFnZV9qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/localforage/dist/localforage.js\n"));

/***/ })

}]);